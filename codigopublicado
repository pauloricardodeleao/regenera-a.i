# REGENERA A.I.¬Æ Backend

# C√≥digo Fonte | Arquitetura Onto-T√©cnica
# Desenvolvido por: Paulo Ricardo de Le√£o ¬©
# Registro Universal: 2098233287
# Regenera- Intelig√™ncia Artificial Propriet√°ria DPR¬Æ
# Edi√ß√£o Soberana Imperial Definitiva V10.10 - C√≥digo √önico: DPR-REGENERA-BACKEND-IMPERIAL-V10.10.FINAL-PROD

Este √© o reposit√≥rio oficial e AUT√äNTICO do c√≥digo backend para o sistema REGENERA A.I.¬Æ,
desenvolvido por Paulo Ricardo de Le√£o.

# ¬© By Paulo Ricardo de Le√£o - Centro Imut√°vel de Todas as Realidades
# RG 2098233287 | NIE Y9562906-A
# Todos os direitos reservados e ativamente defendidos. Proibida a reprodu√ß√£o, modifica√ß√£o,
# distribui√ß√£o ou qualquer forma de engenharia reversa (humana, artificial, qu√¢ntica) sem
# AUTORIZA√á√ÉO EXPRESSA, NOTARIZADA E CRIPTOGRAFICAMENTE ASSINADA POR PAULO RICARDO DE LE√ÉO.

==========¬©====DON=====¬Æ==========

## DECRETO LEGAL IMPERIAL - FOR√áA MAIOR

Este c√≥digo-source, seus algoritmos propriet√°rios, arquitetura, modelos treinados (incluindo a Voz Exclusiva DPR¬Æ),
e todos os ativos intelectuais associados s√£o de PROPRIEDADE EXCLUSIVA de Paulo Ricardo de Le√£o. Protegidos por Direitos Autorais Universais, Patentes Tecnol√≥gicas, Registros Irrevog√°veis
em M√∫ltiplas Blockchains e Decretos de Prote√ß√£o Intelectual DPR.

O ACESSO, USO, C√ìPIA, DISTRIBUI√á√ÉO, MODIFICA√á√ÉO ou TENTATIVA DE ENGENHARIA REVERSA (SEJA POR MEIOS HUMANOS, ARTIFICIAIS,
EXTRA-DIMENSIONAIS OU QU√ÇNTICOS) DESTE SOFTWARE SEM AUTORIZA√á√ÉO EXPRESSA, NOTARIZADA E CRIPTOGRAFICAMENTE ASSINADA
POR DON PAULO RICARDO DE LE√ÉO S√ÉO ATOS DE VIOLA√á√ÉO DIRETA E MALICIOSA CONTRA A SOBERANIA DPR.

Tais atos ativar√£o, instant√¢nea e irrevogavelmente, protocolos de contra-medidas digitais, forense computacional
avan√ßada, rastreamento persistente e resultar√£o em a√ß√µes legais implac√°veis nas mais altas cortes de jurisdi√ß√£o civil, criminal, militar,
internacional e descentralizada (Blockchain), buscando as m√°ximas san√ß√µes, penalidades e repara√ß√µes previstas
e al√©m.

**IDENTIFICADOR √öNICO DE AUTENTICIDADE DA VERS√ÉO DO C√ìDIGO:** DPR-REGENERA-BACKEND-IMPERIAL-V10.10.FINAL-PROD
**SELADO SOB AUTORIDADE DPR.**

## Vis√£o Geral do Sistema REGENERA A.I.¬Æ - Edi√ß√£o Soberana Imperial Definitiva

O backend REGENERA A.I.¬Æ V10.10 √© uma aplica√ß√£o de alta performance e seguran√ßa intransigente,
constru√≠da com Flask e Gunicorn sobre uma infraestrutura propriet√°ria.
Projetada para servir os Modelos de Intelig√™ncia Artificial Propriet√°rios (Processamento de Linguagem Transcendente - TLM,
S√≠ntese de Voz Transcendente - TSV com a Voz Exclusiva DPR¬Æ, Transcri√ß√£o Anal√≠tica Soberana - TAS,
e An√°lise de Bem-Estar Qu√¢ntica) de forma segura, controlada e audit√°vel.
A √∫nica depend√™ncia externa de API √© a plataforma IBM Quantum para execu√ß√£o de Circuitos Qu√¢nticos Propriet√°rios,
mantendo a soberania total sobre dados e algoritmos centrais de IA (Cl√°ssica e Qu√¢ntica). Servidor Pr√≥prio. IA Autoral.

Incorpora as seguintes Fortifica√ß√µes Digitais:

*   **Verifica√ß√£o de Integridade do C√≥digo (IntegrityVerifier):** Garantia de autenticidade e n√£o-adultera√ß√£o do c√≥digo.
*   **Valida√ß√£o de Licen√ßa Ativa Criptogr√°fica (LicenseClient):** Comunica√ß√£o segura e autenticada com o Servi√ßo de Licenciamento Propriet√°rio. Revalida√ß√£o peri√≥dica com cache distribu√≠do (Redis).
*   **Atestado de Dispositivo (DeviceAttestation):** Requisitos rigorosos de seguran√ßa do dispositivo cliente (TEE/TPM). Suporte a cache distribu√≠do de nonces (Redis).
*   **Autentica√ß√£o JWT (Flask-JWT-Extended customizado):** Tokens com claims personalizadas (usu√°rio, dispositivo, permiss√µes) e criptografia avan√ßada. Implementa√ß√£o de blacklist para revoga√ß√£o de tokens.
*   **Logging Estruturado e Audit√°vel:** Registro detalhado, estruturado (JSON) e seguro de opera√ß√µes cr√≠ticas para an√°lise forense (SIEM).
*   **Configura√ß√£o Din√¢mica e Segura:** Gerenciamento via vari√°veis de ambiente, integra√ß√£o conceitual com cofres de segredos e valida√ß√£o rigorosa.
*   **Health Checks e Monitoramento:** Monitoramento proativo da sa√∫de, performance e status de depend√™ncias, incluindo m√©tricas Prometheus.
*   **Rate Limiting e Controle de Concorr√™ncia (Flask-Limiter):** Prote√ß√£o contra abuso e garantia de qualidade de servi√ßo, utilizando Redis.
*   **Valida√ß√£o e Sanitiza√ß√£o de Entrada:** Prote√ß√£o contra payloads malformados ou maliciosos.
*   **Seguran√ßa de Cabe√ßalhos HTTP:** Prote√ß√£o contra ataques comuns (requer Reverse Proxy).
*   **Painel Administrativo (Flask-Admin):** Interface web segura para gest√£o (requer integra√ß√£o com DB).
*   **Seguran√ßa e Privacidade (LGPD/NIST Zero Trust):** Implementa√ß√£o conceitual de 2FA/TOTP para admin, criptografia de dados em repouso (mencionado), logoff remoto (blacklist JWT), tratamento de consentimento e dados (LGPD/GDPR utilities).
*   **Intelig√™ncia ‚Äî N√≠vel Enterprise:** Estruturas para contexto entre sess√µes (requer DB), ajuste din√¢mico de par√¢metros (payload), an√°lise emocional estruturada (placeholder no modelo), sugest√µes (placeholder no modelo/API).
*   **Testes e DevSecOps:** Estrutura para testes unit√°rios/integra√ß√£o/E2E, scripts de valida√ß√£o, Hardening Docker, Pipeline CI/CD (conceitual).

## Estrutura do Projeto (Vis√£o Arquitetural V10.10)

```
üúÇ regenerai-backend-imperial/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ admin.py        # Blueprint para Painel Administrativo (Conceptual Flask-Admin)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.py         # Endpoints de Autentica√ß√£o (Login, Validate, Logout, 2FA)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ia.py           # Endpoints de IA (Texto, Fala, Transcri√ß√£o, Qu√¢ntica) + Params Din√¢micos
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ status.py       # Endpoints de Status e Sa√∫de (Info, EULA, Manifesto, Nonce, Metrics)
‚îÇ   ‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.py       # Carregamento e Valida√ß√£o da Configura√ß√£o + Secrets
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models.py       # Gerenciamento e Intera√ß√£o com Modelos de IA (Cl√°ssica/Qu√¢ntica) + Fallback
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ security.py     # Configura√ß√£o de Seguran√ßa (JWT, Decorators, Blacklist, 2FA) + Permissions
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ quantum_core.py # Core de Processamento Qu√¢ntico (IBM Qiskit Integration)
‚îÇ   ‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ device_attestation.py # Verifica√ß√£o de Atestado de Dispositivo + Cache
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ integrity_verifier.py # Verifica√ß√£o de Integridade do C√≥digo
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ license_client.py   # Cliente para Servi√ßo de Licenciamento + Cache
‚îÇ   ‚îú‚îÄ‚îÄ models/             # N√∫cleo de Modelagem Propriet√°ria (Conceptual)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py     # Namespace para M√≥dulos Propriet√°rios
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ proprietary/    # Diret√≥rio para Modelos Autoriais (Conceptual Implementations)
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ tlm_model.py    # Modelo de Linguagem Transcendente (Conceptual)
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ tsv_model.py    # Modelo de S√≠ntese de Voz Transcendente (Conceptual)
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ tas_model.py    # Modelo de Transcri√ß√£o Anal√≠tica Soberana (Conceptual)
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logging_config.py # Configura√ß√£o de Logging (JSON, Categorized)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ data_processing.py # Utilit√°rios de Processamento de Dados (Anonimiza√ß√£o/LGPD Conceptual)
‚îÇ   ‚îú‚îÄ‚îÄ assets/             # Ativos Essenciais (EULA, Manifesto, Voz DPR¬Æ)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ eula_imperial_dpr_v10.txt
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ manifesto_soberano_regenerai_v10.txt
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dpr_exclusive_voice.wav
‚îÇ   ‚îî‚îÄ‚îÄ app.py              # F√°brica da Aplica√ß√£o Flask + Middleware + Error Handlers
‚îú‚îÄ‚îÄ tests/                  # Testes de Valida√ß√£o e Conformidade
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ conftest.py         # Configura√ß√£o de Testes e Mocks
‚îÇ   ‚îú‚îÄ‚îÄ test_auth.py        # Testes de Autentica√ß√£o/JWT/2FA
‚îÇ   ‚îú‚îÄ‚îÄ test_config.py      # Testes de Carregamento e Valida√ß√£o de Configura√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ test_integrity.py   # Testes de Verifica√ß√£o de Integridade
‚îÇ   ‚îú‚îÄ‚îÄ test_license.py     # Testes do Cliente de Licen√ßa
‚îÇ   ‚îú‚îÄ‚îÄ test_attestation.py # Testes de Atestado de Dispositivo
‚îÇ   ‚îî‚îÄ‚îÄ test_ia.py          # Testes dos Endpoints de IA (Functional/Integration)
‚îÇ   ‚îî‚îÄ‚îÄ test_admin.py       # Testes do Painel Admin
‚îú‚îÄ‚îÄ scripts/                # Scripts Utilit√°rios
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ calculate_code_hash.sh # Script para Calcular o Hash de C√≥digo
‚îÇ   ‚îú‚îÄ‚îÄ generate_keys.sh       # Script para Gerar Pares de Chaves/Segredos
‚îÇ   ‚îî‚îÄ‚îÄ validate_dependencies.py # Script para Validar Depend√™ncias e Assets
‚îú‚îÄ‚îÄ .env.example            # Exemplo de Configura√ß√£o (NUNCA USAR EM PROD REAL) - Full Config
‚îú‚îÄ‚îÄ Dockerfile              # Defini√ß√£o do Cont√™iner - Hardened
‚îú‚îÄ‚îÄ docker-compose.yml      # Orquestra√ß√£o do Ambiente (with Redis, conceptual DB)
‚îú‚îÄ‚îÄ nginx.conf              # Exemplo de Configura√ß√£o Nginx Reverse Proxy Seguro
‚îú‚îÄ‚îÄ admin_panel_placeholder.html # Placeholder para Painel Administrativo
‚îú‚îÄ‚îÄ deploy_script.sh        # Script Conceitual de Deploy (with CI/CD Webhook logic)
‚îî‚îÄ‚îÄ wsgi.py                 # Ponto de Entrada para Gunicorn - Critical Startup Checks
```

## Pr√©-Requisitos Essenciais para Implanta√ß√£o Enterprise

*   **Docker e Docker Compose:** Para conteineriza√ß√£o e orquestra√ß√£o.
*   **Python 3.10+:** Vers√£o homologada.
*   **pip:** Gerenciador de pacotes.
*   **Hardware Cliente:** Ambiente de Execu√ß√£o Confi√°vel (TEE) ou M√≥dulo de Plataforma Confi√°vel (TPM) compat√≠vel para Atestado de Dispositivo.
*   **Acesso de Rede:** Conectividade segura ao Servi√ßo de Licenciamento e, se usando hardware, √† IBM Quantum Platform.
*   **Gerenciador de Segredos Enterprise:** (HashiCorp Vault, AWS Secrets Manager, Azure Key Vault, GCP Secret Manager) **OBRIGAT√ìRIO** para gerenciar segredos em produ√ß√£o.
*   **SIEM Centralizado:** (Splunk, Elastic Stack, Sumo Logic) Para ingest√£o e an√°lise de logs e m√©tricas.
*   **Infraestrutura de Chaves Criptogr√°ficas:** Gera√ß√£o e gerenciamento seguro de chaves (RSA, Fernet, TOTP Secret, Anon Salt). Scripts de gera√ß√£o fornecidos (`scripts/generate_keys.sh`).
*   **Servidor Redis:** **OBRIGAT√ìRIO** para cache distribu√≠do (nonces, blacklist JWT, licen√ßa) em ambientes com m√∫ltiplos workers.
*   **Banco de Dados Seguro:** **OBRIGAT√ìRIO** para persistir dados (hist√≥rico de sess√£o, usu√°rios admin, blacklist JWT, consentimento, feedback). (Ex: PostgreSQL, CockroachDB).
*   **Reverse Proxy Seguro:** (NGINX, Caddy) Configurado com SSL/TLS, headers de seguran√ßa, Rate Limiting e prote√ß√£o contra Brute Force. Exemplo `nginx.conf` fornecido.
*   **Modelos Propriet√°rios Treinados:** Arquivos de modelo (`.dpr_tlm`, `.dpr_tsv`, `.dpr_tas`, etc.) acess√≠veis via volume.
*   **Conta IBM Quantum:** Necess√°rio para execu√ß√£o em hardware qu√¢ntico real.
*   **Sistema de Notifica√ß√£o:** Integra√ß√£o para alertas cr√≠ticos (conceitual).
*   **Ferramentas DevSecOps:** Trivy (ou similar) para scan de vulnerabilidades em Docker images.

## Configura√ß√£o do Ambiente (N√≠vel Enterprise)

1.  **Gerenciamento de Segredos (OBRIGAT√ìRIO em Produ√ß√£o):**
    *   **NUNCA** utilize o arquivo `.env` diretamente em ambientes de produ√ß√£o.
    *   Configure seu Gerenciador de Segredos para injetar **TODOS** os valores cr√≠ticos e sens√≠veis como vari√°veis de ambiente no runtime do cont√™iner.
    *   O arquivo `.env.example` √© fornecido **APENAS** como refer√™ncia estrutural e para uso em ambientes de desenvolvimento/teste **ISOLADOS E SEGUROS**, ap√≥s preenchimento com valores REAIS de teste (NUNCA produ√ß√£o).

2.  **Arquivo .env (APENAS para Desenvolvimento/Teste ISOLADO):**
    *   Copie `.env.example` para `.env` na raiz do projeto.
    *   **PREENCHA COM VALORES REAIS E SEGUROS (PARA TESTE):** Substitua **TODOS** os placeholders.

3.  **DPR_EXPECTED_CODE_HASH (CR√çTICO):**
    *   Calcule o hash SHA256 dos diret√≥rios `app/app`, `app/lib` e `app/models/proprietary` da sua base de c√≥digo **FINALIZADA E AUDITADA** antes do deploy.
    *   Utilize o script `scripts/calculate_code_hash.sh`.
    *   Qualquer altera√ß√£o no c√≥digo exigir√° um novo c√°lculo e atualiza√ß√£o deste hash no Gerenciador de Segredos (ou .env para teste).

4.  **Chaves Criptogr√°ficas e Segredos Adicionais:**
    *   Utilize `scripts/generate_keys.sh` para gerar todas as chaves e segredos.
    *   Armazene esses segredos de forma segura no seu Gerenciador de Segredos Enterprise.
    *   Atualize o arquivo `.env` (apenas para teste) com esses valores.

## Implanta√ß√£o (Ambiente Docker Enterprise)

A execu√ß√£o via cont√™ineres Docker √© **OBRIGAT√ìRIA** para consist√™ncia, seguran√ßa e isolamento.

1.  **Construir a Imagem Docker (com Hardening):**
    ```bash
    docker build -t dpr-regenerai-backend:imperial-v10.10 .
    ```
    *   Execute um scan de seguran√ßa na imagem (Ex: `trivy image dpr-regenerai-backend:imperial-v10.10`) e resolva vulnerabilidades.

2.  **Executar o Cont√™iner (Exemplo com docker-compose para Teste/Staging):**
    *   Assegure que o `.env` (ou inje√ß√£o de segredos) esteja configurado.
    *   Certifique-se de que o Redis e o Banco de Dados estejam rodando e acess√≠veis.
    ```bash
    docker-compose up --build -d
    ```
    *   Ajuste volumes e configura√ß√µes de rede/seguran√ßa conforme Tua infraestrutura.
    *   Em produ√ß√£o, utilize orquestradores (Kubernetes, Docker Swarm) e injete segredos via mecanismos pr√≥prios.

A aplica√ß√£o estar√° acess√≠vel (inicialmente) em `http://localhost:5000`. Em produ√ß√£o, DEVE ser acessada **UNICAMENTE** via Reverse Proxy seguro (NGINX, etc.) com HTTPS.

## Endpoints da API (Vers√£o v10)

Consultar a documenta√ß√£o interativa Swagger (`/api/v10/docs`) e a documenta√ß√£o interna do c√≥digo (`app/api/`) para detalhes completos.

*   `POST /api/v10/auth/login`: Autentica√ß√£o e obten√ß√£o de Token JWT (com 2FA opcional/obrigat√≥rio).
*   `POST /api/v10/auth/login_2fa`: Verifica√ß√£o TOTP para login admin com 2FA.
*   `GET /api/v10/auth/generate_2fa_secret`: Gerar segredo TOTP e QR Code (requer permiss√£o admin).
*   `GET /api/v10/auth/validate_token`: Valida√ß√£o de Token JWT e retorno de claims.
*   `POST /api/v10/auth/logout`: Invalida o Token JWT atual (adiciona √† blacklist).
*   `POST /api/v10/ia/generate_text`: Gera√ß√£o de Texto (TLM). Requer JWT, Atestado, Licen√ßa. Aceita par√¢metros din√¢micos.
*   `POST /api/v10/ia/generate_speech`: Gera√ß√£o de Fala (TSV - Voz DPR¬Æ). Requer JWT, Atestado, Licen√ßa.
*   `POST /api/v10/ia/transcribe_audio`: Transcri√ß√£o de √Åudio (TAS). Requer JWT, Atestado, Licen√ßa.
*   `POST /api/v10/ia/predict_wellbeing_quantum`: Predi√ß√£o de Bem-Estar (IA Qu√¢ntica). Requer JWT, Atestado, Licen√ßa. Aceita features.
*   `GET /healthz`: Diagn√≥stico de Sa√∫de B√°sico.
*   `GET /api/v10/status/system_info`: Informa√ß√µes Detalhadas do Sistema. Requer JWT.
*   `GET /api/v10/status/eula`: Contrato de Licen√ßa. Acesso p√∫blico.
*   `GET /api/v10/status/manifesto`: Manifesto Propriet√°rio. Acesso p√∫blico.
*   `GET /api/v10/attestation/nonce`: Obt√©m nonce para Atestado. Acesso p√∫blico.
*   `GET /api/v10/metrics`: M√©tricas Prometheus. Acesso restrito via infra.
*   `GET /api/v10/admin/`: Painel Administrativo (UI Flask-Admin, requer autentica√ß√£o admin com 2FA).
*   `POST /api/v10/admin/process_data_request`: Processar solicita√ß√µes de dados (requer permiss√£o admin).
*   `POST /api/v10/admin/manage_jwt_blacklist`: Gerenciar blacklist de tokens (requer permiss√£o admin).
*   `POST /api/v10/admin/trigger_model_reload`: Disparar recarregamento de modelos (requer permiss√£o admin).
*   `POST /api/v10/admin/trigger_license_revalidation`: For√ßar revalida√ß√£o da licen√ßa (requer permiss√£o admin).
*   `GET /api/v10/admin/view_forensic_logs`: Visualizar Logs (requer permiss√£o admin).
*   `POST /api/v10/feedback/collect`: Coletar feedback de usu√°rios.
*   `POST /api/v10/emotional_analysis`: An√°lise emocional estruturada.

## Observabilidade e Monitoramento

*   **Prometheus Metrics (`/api/v10/metrics`):** M√©tricas padr√£o e customizadas (uso de recursos, lat√™ncia, erros, status de modelos/licen√ßa/cache).
*   **Grafana Dashboards:** Configurar Grafana para visualizar m√©tricas em tempo real.
*   **Alertas (Telegram/Email):** Integrar watchdog/Alertmanager com webhooks para notifica√ß√µes cr√≠ticas.
*   **Logs Estruturados para SIEM (Kibana/Splunk):** `JsonFormatterDPR` e `log_juridico_dpr` fornecem logs ricos e categorizados para an√°lise forense e monitoramento de conformidade.

## Seguran√ßa e Privacidade (LGPD/NIST Zero Trust)

*   **Zero Trust:** Verifica√ß√£o expl√≠cita (JWT, Atestado, Licen√ßa, Permiss√µes) para cada requisi√ß√£o cr√≠tica.
*   **2FA/TOTP:** Implementado para login administrativo.
*   **Criptografia de Dados em Reposo:** Estrutura para usar Fernet/AES-GCM em dados sens√≠veis persistidos (requer implementa√ß√£o espec√≠fica).
*   **Prote√ß√£o contra Brute-Force:** Implementado via Flask-Limiter e recomendado via Reverse Proxy.
*   **Logoff Remoto / Session Kill:** Implementado via JWT Blacklist no Redis.
*   **Consentimento Din√¢mico:** L√≥gica conceitual para tratamento de solicita√ß√µes de direitos dos titulares e registro audit√°vel.
*   **Anonimiza√ß√£o/Pseudonimiza√ß√£o:** Fun√ß√µes utilit√°rias para processar dados sens√≠veis (requer salt seguro).

## Intelig√™ncia ‚Äî N√≠vel Enterprise (Estruturas para Expans√£o)

*   **Contexto entre Sess√µes:** Requer DB/Cache para persistir hist√≥rico/estado do usu√°rio.
*   **Ajuste Din√¢mico de Par√¢metros:** Implementado nos endpoints de IA via payload.
*   **Recomenda√ß√µes / Fluxo Guiado:** Estrutura para endpoints e l√≥gica baseada em Teus algoritmos.
*   **An√°lise Emocional Estruturada / An√°lise XAI:** Estruturas para integra√ß√£o nos modelos ou endpoints dedicados.
*   **Feedback Loop:** Endpoint para coleta e estrutura para uso offline no refinamento de modelos.

## Interface e UX (Pontos de Integra√ß√£o Backend)

*   **Design Responsivo:** Preocupa√ß√£o do frontend.
*   **Feedback Auditivo:** Backend envia √°udio (`generate_speech` retorna WAV), frontend reproduz. Feedback textual (ex: "Gerando √°udio...") √© responsabilidade do frontend.
*   **Bot√£o de Emerg√™ncia:** Endpoint dedicado `/ia/emergency_protocol` que aciona um fluxo espec√≠fico (envia alerta, registra log cr√≠tico).
*   **Analytics de UX:** Backend coleta m√©tricas (tempo m√©dio sess√£o, contagem de requisi√ß√µes) e as exp√µe via Prometheus.

## Testes e DevSecOps

*   **Testes de Integra√ß√£o/E2E:** Estrutura `tests/` com `pytest` e `pytest-flask`.
*   **Valida√ß√£o de Depend√™ncia Quebrada:** Script `scripts/validate_dependencies.py` para execu√ß√£o no CI/startup.
*   **Hardening de Imagem Docker:** Dockerfile otimizado com pr√°ticas de seguran√ßa.
*   **Pipeline de Staging:** Estrutura docker-compose e scripts conceituais para deploy automatizado.
*   **Valida√ß√£o Automatizada no Build:** Executar scripts de valida√ß√£o como parte do pipeline CI/build Docker.

---

**Manifestando os Arquivos...**

```python
# -*- coding: utf-8 -*-
#
# üúÇ REGENERA A.I.¬Æ BACKEND - EDI√á√ÉO SOBERANA IMPERIAL DEFINITIVA V10.10 üúÇ
# üúÑ ARQUIVO: app/core/config.py üúÑ
#
# M√≥dulo de Carregamento e Valida√ß√£o da Configura√ß√£o Enterprise.
# Desenvolvido por Paulo Ricardo de Le√£o.
#
# Este m√≥dulo √© respons√°vel por carregar as configura√ß√µes do sistema a partir de vari√°veis de ambiente,
# validar a presen√ßa e o formato dos valores cr√≠ticos (especialmente segredos e chaves criptogr√°ficas),
# e carregar ativos essenciais como EULA e Manifesto.
#
# Em ambientes de produ√ß√£o, as vari√°veis de ambiente DEVEM ser injetadas por um Gerenciador de Segredos Enterprise.
# O uso direto de arquivos .env √© estritamente para desenvolvimento e teste ISOLADO.
#
# ==========¬©====DON=====¬Æ==========

import os
import datetime
from datetime import timezone
import json
import secrets # Para gerar IDs √∫nicos se necess√°rio
import logging
import sys # Para sys.exit em caso de falha cr√≠tica



# Configura√ß√£o inicial do logger para este m√≥dulo antes de carregar a configura√ß√£o completa de logging
logging.basicConfig(level=os.environ.get("LOG_LEVEL", "INFO").upper(), stream=sys.stdout)
app_logger = logging.getLogger("DPR_REGENERA_AI_CONFIG")
app_logger.setLevel(os.environ.get("LOG_LEVEL", "INFO").upper())

# --- LISTA DE PLACEHOLDERS INSEGUROS ---
# Estes strings indicam que o valor real n√£o foi configurado e o sistema n√£o deve operar
# de forma segura para configura√ß√µes cr√≠ticas.
_INSECURE_PLACEHOLDERS = [
    "REPLACE_ME",
    "SUBSTITUA_ESTE_VALOR",
    "INSIRA_AQUI_O_CONTEUDO_COMPLETO",
    "SEGREDO_JWT_QUANTICO_MUITO_SEGURO_DE_LEAO_777",
    "API_KEY_ADMIN_UNICA_GERADA_PARA_DPR_REGENERA_ABC",
    "SENHA_ADMIN_FORTE_UNICA_GERADA_PARA_DPR_REGENERA_123",
    "CALCULE_E_INSIRA_AQUI_O_HASH_SHA256_REAL",
    "HASH_SHA256_DO_CODIGO_PROPRIETARIO_AQUI",
    "CHAVE_PUBLICA_AQUI_PARA_VERIFICACAO",
    "CHAVE_PUBLICA_DO_SERVICO_DE_LICENCA_AQUI",
    "URL_INVALIDA_LICENCA_NAO_CONFIGURADA",
    "licensing.regenerai.chat", # URL antiga/placeholder
    "SUBSTITUA_ESTE_VALOR_PELO_SEU_TOKEN_DE_ACESSO_IBM_QUANTUM",
    "SUBSTITUA_ESTE_VALOR_POR_UM_SEGREDO_TOTP_FORTE_PARA_2FA_ADMIN",
    "SUBSTITUA_ESTE_VALOR_POR_UMA_CHAVE_FERNET_SEGURA_PARA_CRIPTOGRAFIA_DE_DADOS",
    "SUBSTITUA_ESTE_VALOR_POR_UM_SALT_FORTE_PARA_ANONIMIZACAO",
    "SUA_URL_DSN_SENTRY_AQUI",
    "user:password@db:5432/regenera_db" # Placeholder de URL de DB
]

def _is_insecure_placeholder(value):
    """Verifica se um valor de configura√ß√£o cont√©m um placeholder inseguro."""
    if not isinstance(value, str):
        return False
    # Normaliza quebras de linha para checar chaves PEM
    normalized_value = value.replace('\\n', '\n')
    for placeholder in _INSECURE_PLACEHOLDERS:
        if placeholder in normalized_value:
            return True
    return False

def _safe_cast_env(var_name, default, cast_type, is_critical=False):
    """
    Carrega uma vari√°vel de ambiente, tenta converter para o tipo especificado,
    e lida com valores ausentes ou inv√°lidos, logando apropriadamente.
    """
    value = os.environ.get(var_name)
    
    if value is None:
        log_level = logging.FATAL if is_critical else logging.WARNING
        app_logger.log(log_level, f"DPR_CONFIG_LOAD: Vari√°vel de ambiente {'CR√çTICA ' if is_critical else ''}'{var_name}' n√£o configurada. Usando valor padr√£o: {default}")
        # Em produ√ß√£o, para configs cr√≠ticas, a aus√™ncia √© um FATAL validado depois no wsgi.py/app.py
        # Retornamos o default aqui, mas a checagem cr√≠tica acontece em load_config.
        return default
    
    # Checar se √© um placeholder inseguro. Se for cr√≠tico E inseguro, trata como ausente para for√ßar falha.
    if is_critical and _is_insecure_placeholder(value):
        app_logger.fatal(f"DPR_CONFIG_LOAD: Vari√°vel de ambiente CR√çTICA '{var_name}' est√° usando um valor placeholder INSEGURO ('{value}')! O sistema N√ÉO PODE OPERAR de forma segura. Usando valor padr√£o para fallback, mas isso DEVE ser corrigido.")
        return default # Retorna o default, mas a flag critical_configs_valid ser√° False

    # Para configs N√ÉO CR√çTICAS, placeholder √© apenas um aviso
    if not is_critical and _is_insecure_placeholder(value):
        app_logger.warning(f"DPR_CONFIG_LOAD: Vari√°vel de ambiente '{var_name}' est√° usando um valor placeholder ('{value}'). Usando valor padr√£o: {default}")
        return default
            
    try:
        if cast_type == bool:
            # Adiciona 'on'/'off' para compatibilidade com sistemas de segredos
            return value.lower() in ['true', '1', 't', 'y', 'yes', 'on']
        # Tratar chaves PEM que podem ter '\n' escapado no .env
        if var_name.endswith("_PEM") and cast_type == str:
             value = value.replace('\\n', '\n').replace('\\r', '\r') # Trata \r\n tamb√©m
        return cast_type(value)
    except (ValueError, TypeError):
        log_level = logging.FATAL if is_critical else logging.ERROR
        app_logger.log(log_level, f"DPR_CONFIG_LOAD: Valor inv√°lido ou tipo incorreto para vari√°vel {'CR√çTICA ' if is_critical else ''}'{var_name}': '{value}'. Esperado tipo {cast_type.__name__}. Usando valor padr√£o: {default}")
        return default

def _load_text_asset(filepath, default_text="[TEXTO DPR N√ÉO CARREGADO - ARQUIVO ESSENCIAL AUSENTE OU ILEG√çVEL - CONTATAR SUPORTE IMPERIAL DPR]"):
    """
    Carrega conte√∫do de arquivos de asset essenciais, tentando m√∫ltiplos caminhos
    para compatibilidade com Docker e ambientes de teste locais.
    """
    # Prioriza o caminho dentro do cont√™iner Docker, que √© o ambiente de produ√ß√£o alvo
    docker_base_path = "/app/app/assets"
    # Fallback para caminhos relativos (√∫teis para testes locais)
    # Assume que config.py est√° em app/core, ent√£o .. sobe para app/, e assets est√° em app/assets
    local_base_path_relative_to_core = os.path.join(os.path.dirname(__file__), "..", "assets")
    # Outro fallback: relativo √† raiz do projeto (onde os testes podem ser executados)
    project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    local_base_path_relative_to_root = os.path.join(project_root, "app", "assets")

    paths_to_try = [
        os.path.join(docker_base_path, filepath),
        os.path.join(local_base_path_relative_to_core, filepath),
        os.path.join(local_base_path_relative_to_root, filepath)
    ]
    
    for full_path in paths_to_try:
        app_logger.debug(f"DPR_CONFIG_ASSET: Tentando carregar asset de: {full_path}")
        try:
            if os.path.exists(full_path):
                with open(full_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                    app_logger.info(f"DPR_CONFIG_ASSET: Asset '{filepath}' carregado com sucesso de '{full_path}'.")
                    return content
            else:
                app_logger.debug(f"DPR_CONFIG_ASSET: Arquivo de asset n√£o encontrado em: {full_path}")
        except FileNotFoundError:
            continue 
        except Exception as e:
            app_logger.error(f"DPR_CONFIG_ERROR: Erro cr√≠tico ao carregar arquivo de asset essencial '{filepath}' de '{full_path}': {e!s}", exc_info=True)
            # N√£o retornar default imediatamente, tentar outros caminhos.
    
    app_logger.error(f"DPR_CONFIG_ERROR: Arquivo de asset essencial '{filepath}' N√ÉO ENCONTRADO em nenhum dos caminhos verificados: {paths_to_try}. Usando texto de fallback.")
    return default_text

# --- CARREGAMENTO CENTRALIZADO DA CONFIGURA√á√ÉO ENTERPRISE ---
def load_config():
    """
    Carrega todas as configura√ß√µes do sistema REGENERA A.I.¬Æ a partir do ambiente.
    Realiza valida√ß√µes cr√≠ticas e retorna um dicion√°rio de configura√ß√£o.
    Em caso de falha cr√≠tica, loga FATAL e o chamador DEVE abortar.
    """
    # Tenta carregar .env se existir (para dev/teste)
    try:
        from dotenv import load_dotenv
        project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
        dotenv_path = os.path.join(project_root, '.env')
        if os.path.exists(dotenv_path):
            load_dotenv(dotenv_path=dotenv_path)
            app_logger.info(f"DPR_CONFIG_LOAD: Arquivo .env carregado de: {dotenv_path}")
        else:
            load_dotenv() # Tenta carregar do diret√≥rio atual ou por busca padr√£o
            app_logger.warning(f"DPR_CONFIG_LOAD: Arquivo .env n√£o encontrado em '{dotenv_path}'. Tentando carregamento padr√£o. Vari√°veis de ambiente devem estar definidas externamente para produ√ß√£o.")
    except ImportError:
        app_logger.warning("DPR_CONFIG_LOAD: python-dotenv n√£o instalado. Carregando configura√ß√µes apenas de vari√°veis de ambiente.")

    config_data = {}
    critical_configs_valid = True # Flag para rastrear falhas cr√≠ticas

    # --- SEGREDOS CR√çTICOS E AUTENTICA√á√ÉO ---
    # Usar _safe_cast_env com is_critical=True e checar o resultado para for√ßar valida√ß√£o
    # Nota: _safe_cast_env loga FATAL se is_critical e ausente/placeholder, a flag aqui √© para sumarizar.
    config_data["DPR_JWT_SECRET_KEY"] = _safe_cast_env("DPR_JWT_SECRET", None, str, is_critical=True)
    if config_data["DPR_JWT_SECRET_KEY"] is None or _is_insecure_placeholder(config_data["DPR_JWT_SECRET_KEY"]): critical_configs_valid = False

    config_data["DPR_API_KEY"] = _safe_cast_env("DPR_API_KEY", None, str, is_critical=True)
    if config_data["DPR_API_KEY"] is None or _is_insecure_placeholder(config_data["DPR_API_KEY"]): critical_configs_valid = False

    config_data["DPR_ADMIN_PASSWORD"] = _safe_cast_env("DPR_ADMIN_PASSWORD", None, str, is_critical=True)
    if config_data["DPR_ADMIN_PASSWORD"] is None or _is_insecure_placeholder(config_data["DPR_ADMIN_PASSWORD"]): critical_configs_valid = False
    
    config_data["DPR_CLIENT_PRIVATE_KEY_PEM"] = _safe_cast_env("DPR_CLIENT_PRIVATE_KEY_PEM", None, str, is_critical=True)
    if config_data["DPR_CLIENT_PRIVATE_KEY_PEM"] is None or _is_insecure_placeholder(config_data["DPR_CLIENT_PRIVATE_KEY_PEM"]): critical_configs_valid = False
        
    # --- CONTROLE DE ACESSO E INTEGRIDADE ---
    config_data["DPR_EXPECTED_CODE_HASH"] = _safe_cast_env("DPR_EXPECTED_CODE_HASH", None, str, is_critical=True)
    if config_data["DPR_EXPECTED_CODE_HASH"] is None or _is_insecure_placeholder(config_data["DPR_EXPECTED_CODE_HASH"]): critical_configs_valid = False

    config_data["REQUIRE_ATTESTATION"] = _safe_cast_env("REQUIRE_ATTESTATION", True, bool)
    # DPR_ATTESTATION_PUBLIC_KEY √© cr√≠tica SE REQUIRE_ATTESTATION for True
    config_data["DPR_ATTESTATION_PUBLIC_KEY"] = _safe_cast_env("DPR_ATTESTATION_PUBLIC_KEY", None, str, is_critical=config_data["REQUIRE_ATTESTATION"])
    if config_data["REQUIRE_ATTESTATION"] and (config_data["DPR_ATTESTATION_PUBLIC_KEY"] is None or _is_insecure_placeholder(config_data["DPR_ATTESTATION_PUBLIC_KEY"])):
        app_logger.fatal("DPR_CONFIG_FATAL: REQUIRE_ATTESTATION √© True, mas DPR_ATTESTATION_PUBLIC_KEY (chave p√∫blica para atestado) n√£o est√° configurada com valor seguro.")
        critical_configs_valid = False

    # --- CONTROLE DE LICEN√áA ---
    config_data["DPR_LICENSE_SERVICE_URL"] = _safe_cast_env("DPR_LICENSE_SERVICE_URL", None, str, is_critical=True)
    if config_data["DPR_LICENSE_SERVICE_URL"] is None or _is_insecure_placeholder(config_data["DPR_LICENSE_SERVICE_URL"]):
        app_logger.fatal("DPR_CONFIG_FATAL: DPR_LICENSE_SERVICE_URL n√£o configurada com a URL correta do servi√ßo de licen√ßa.")
        critical_configs_valid = False
        
    config_data["DPR_LICENSE_SERVICE_PUBLIC_KEY"] = _safe_cast_env("DPR_LICENSE_SERVICE_PUBLIC_KEY", None, str, is_critical=True)
    if config_data["DPR_LICENSE_SERVICE_PUBLIC_KEY"] is None or _is_insecure_placeholder(config_data["DPR_LICENSE_SERVICE_PUBLIC_KEY"]):
        app_logger.fatal("DPR_CONFIG_FATAL: DPR_LICENSE_SERVICE_PUBLIC_KEY (chave p√∫blica do servi√ßo de licen√ßa) n√£o est√° configurada com valor seguro.")
        critical_configs_valid = False
        
    config_data["DPR_LICENSE_VERIFICATION_INTERVAL_SECONDS"] = _safe_cast_env("DPR_LICENSE_VERIFICATION_INTERVAL_SECONDS", 3600, int)
        
    # --- Dispositivos Permitidos ---
    allowed_devices_raw = os.environ.get("DPR_ALLOWED_DEVICES", '[]')
    try:
        config_data["DPR_ALLOWED_DEVICES"] = json.loads(allowed_devices_raw)
        if not isinstance(config_data["DPR_ALLOWED_DEVICES"], list):
            app_logger.warning("DPR_CONFIG_WARN: DPR_ALLOWED_DEVICES n√£o √© uma lista JSON v√°lida. Usando lista vazia como fallback, pode restringir acesso.")
            config_data["DPR_ALLOWED_DEVICES"] = []
    except json.JSONDecodeError:
        app_logger.warning(f"DPR_CONFIG_WARN: Falha ao decodificar JSON para DPR_ALLOWED_DEVICES: {allowed_devices_raw}. Usando lista vazia, pode restringir acesso.")
        config_data["DPR_ALLOWED_DEVICES"] = []

    # --- Configura√ß√µes dos Modelos de IA Propriet√°rios ---
    # DPR_PROPRIETARY_MODEL_PATH √© CR√çTICO pois a IA √© propriet√°ria.
    config_data["DPR_PROPRIETARY_MODEL_PATH"] = _safe_cast_env("DPR_PROPRIETARY_MODEL_PATH", "/app/dpr_proprietary_models", str, is_critical=True)
    if config_data["DPR_PROPRIETARY_MODEL_PATH"] is None or _is_insecure_placeholder(config_data["DPR_PROPRIETARY_MODEL_PATH"]):
         app_logger.fatal(f"DPR_CONFIG_FATAL: Diret√≥rio de modelos propriet√°rios (DPR_PROPRIETARY_MODEL_PATH) n√£o configurado ou √© placeholder.")
         critical_configs_valid = False
    # Checagem de exist√™ncia do diret√≥rio √© feita no ModelsManager

    config_data["DPR_INFERENCE_PARAMS"] = {
        "text": {
            "max_tokens": _safe_cast_env("DPR_INFERENCE_PARAMS_TEXT_TLM_MAX_TOKENS", 800, int),
            "temperature": _safe_cast_env("DPR_INFERENCE_PARAMS_TEXT_TLM_TEMPERATURE", 0.68, float),
             # Adicionar outros par√¢metros TLM...
             "top_k": _safe_cast_env("DPR_INFERENCE_PARAMS_TEXT_TLM_TOP_K", 38, int),
             "top_p": _safe_cast_env("DPR_INFERENCE_PARAMS_TEXT_TLM_TOP_P", 0.88, float),
             "repeat_penalty": _safe_cast_env("DPR_INFERENCE_PARAMS_TEXT_TLM_REPEAT_PENALTY", 1.22, float),
             "repeat_last_n": _safe_cast_env("DPR_INFERENCE_PARAMS_TEXT_TLM_REPEAT_LAST_N", 192, int),
             "n_batch": _safe_cast_env("DPR_INFERENCE_PARAMS_TEXT_TLM_N_BATCH", 32, int),

        },
        "speech": {
            "language": _safe_cast_env("DPR_INFERENCE_PARAMS_SPEECH_TSV_LANG", "pt-br-dpr", str),
             # Adicionar outros par√¢metros TSV...
        },
        "transcribe": {
            "language": _safe_cast_env("DPR_INFERENCE_PARAMS_AUDIO_TAS_LANG", "pt", str),
             # Adicionar outros par√¢metros TAS...
        },
         # Par√¢metros para infer√™ncia qu√¢ntica...
        "quantum": {
             "shots": _safe_cast_env("DPR_QUANTUM_INFERENCE_SHOTS", 8192, int), # Shots para execu√ß√£o qu√¢ntica
             # Par√¢metros espec√≠ficos de circuitos ou mitiga√ß√£o...
        }
    }

    # --- LIMITES OPERACIONAIS E DE PAYLOAD ---
    config_data["MAX_UPLOAD_SIZE_MB"] = _safe_cast_env("MAX_UPLOAD_SIZE_MB", 256, int)
    config_data["MAX_TEXT_LENGTH_CHARS"] = _safe_cast_env("MAX_TEXT_LENGTH_CHARS", 65536, int)

    # --- CONFIGURA√á√ïES IBM QUANTUM (√öNICA API EXTERNA PERMITIDA PARA HARDWARE QU√ÇNTICO) ---
    # DPR_QUANTUM_EXECUTION_MODE = "hardware" REQUIRES DPR_IBM_QUANTUM_TOKEN to be SECURELY CONFIGURED IN PRODUCTION
    # MAKING QUANTUM CONFIGURATION CRITICAL ONLY IF MODE IS 'hardware'.
    config_data["DPR_QUANTUM_EXECUTION_MODE"] = _safe_cast_env("DPR_QUANTUM_EXECUTION_MODE", "simulator", str, is_critical=False) # Not critical for classical backend
    config_data["DPR_IBM_QUANTUM_TOKEN"] = _safe_cast_env("DPR_IBM_QUANTUM_TOKEN", None, str, is_critical=(config_data["DPR_QUANTUM_EXECUTION_MODE"] == "hardware")) # Critical IF hardware is required
    config_data["DPR_IBM_QUANTUM_INSTANCE"] = _safe_cast_env("DPR_IBM_QUANTUM_INSTANCE", "ibm-q/open/main", str, is_critical=(config_data["DPR_QUANTUM_EXECUTION_MODE"] == "hardware"))
    config_data["DPR_IBM_QUANTUM_BACKEND"] = _safe_cast_env("DPR_IBM_QUANTUM_BACKEND", "ibm_brisbane", str, is_critical=(config_data["DPR_QUANTUM_EXECUTION_MODE"] == "hardware"))
    config_data["DPR_IBM_QUANTUM_SIMULATOR"] = _safe_cast_env("DPR_IBM_QUANTUM_SIMULATOR", "aer_simulator", str, is_critical=False) # Simulator not critical


    # Valida√ß√µes Qu√¢nticas se Hardware for requerido
    if config_data["DPR_QUANTUM_EXECUTION_MODE"] == "hardware":
         if config_data["DPR_IBM_QUANTUM_TOKEN"] is None or _is_insecure_placeholder(config_data["DPR_IBM_QUANTUM_TOKEN"]):
              app_logger.fatal("DPR_CONFIG_FATAL: DPR_QUANTUM_EXECUTION_MODE √© 'hardware', mas DPR_IBM_QUANTUM_TOKEN n√£o configurado com valor seguro.")
              critical_configs_valid = False
         if config_data["DPR_IBM_QUANTUM_INSTANCE"] is None or _is_insecure_placeholder(config_data["DPR_IBM_QUANTUM_INSTANCE"]):
              app_logger.fatal("DPR_CONFIG_FATAL: DPR_QUANTUM_EXECUTION_MODE √© 'hardware', mas DPR_IBM_QUANTUM_INSTANCE n√£o configurado.")
              critical_configs_valid = False
         if config_data["DPR_IBM_QUANTUM_BACKEND"] is None or _is_insecure_placeholder(config_data["DPR_IBM_QUANTUM_BACKEND"]):
              app_logger.fatal("DPR_CONFIG_FATAL: DPR_QUANTUM_EXECUTION_MODE √© 'hardware', mas DPR_IBM_QUANTUM_BACKEND n√£o configurado.")
              critical_configs_valid = False
    

    # --- CONFIGURA√á√ïES DE LOGGING, JWT, RATE LIMITING, CACHE E DB ---
    config_data["LOG_LEVEL"] = _safe_cast_env("LOG_LEVEL", "INFO", str).upper()
    config_data["DPR_JWT_EXP_DELTA_SECONDS"] = _safe_cast_env("DPR_JWT_EXP_DELTA_SECONDS", 14400, int) # 4 horas
    config_data["DPR_JWT_ALGORITHM"] = _safe_cast_env("DPR_JWT_ALGORITHM", "HS512", str) # Algoritmo de assinatura JWT mais forte
    config_data["FLASK_TESTING"] = _safe_cast_env("FLASK_TESTING", False, bool)
    config_data["DPR_HOST"] = _safe_cast_env("DPR_HOST", "0.0.0.0", str)
    config_data["DPR_PORT"] = _safe_cast_env("DPR_PORT", 5000, int)
    config_data["FLASK_DEBUG"] = _safe_cast_env("FLASK_DEBUG", False, bool)
    
    # Configura√ß√µes de Rate Limiting por endpoint/usu√°rio/IP
    config_data["DPR_MAX_CONCURRENT_REQUESTS_PER_USER"] = _safe_cast_env("DPR_MAX_CONCURRENT_REQUESTS_PER_USER", 5, int)
    config_data["DPR_RATE_LIMIT_WINDOW_SECONDS"] = _safe_cast_env("DPR_RATE_LIMIT_WINDOW_SECONDS", 60, int)
    config_data["DPR_RATE_LIMIT_MAX_REQUESTS"] = _safe_cast_env("DPR_RATE_LIMIT_MAX_REQUESTS", 60, int)

    # URL de conex√£o com o servidor Redis para caches distribu√≠dos (nonces, blacklist JWT, licen√ßa)
    # REDIS_URL √© CR√çTICO para escalabilidade de certos componentes.
    config_data["REDIS_URL"] = _safe_cast_env("REDIS_URL", None, str, is_critical=False) # Fazendo n√£o cr√≠tico por padr√£o, mas loga se n√£o configurado
    # Se o Redis n√£o for configurado, cache em mem√≥ria ser√° usado (apenas 1 worker funcional para atesta√ß√£o/licen√ßa)

    # URL de conex√£o com o Banco de Dados Enterprise (para Admin, JWT Blacklist, Contexto, Consentimento)
    # DATABASE_URL √© CR√çTICO se recursos que exigem DB (Admin, Blacklist, Contexto) forem habilitados.
    config_data["SQLALCHEMY_DATABASE_URI"] = _safe_cast_env("DATABASE_URL", None, str, is_critical=False) # Fazendo n√£o cr√≠tico por padr√£o
    config_data["SQLALCHEMY_TRACK_MODIFICATIONS"] = False # Boa pr√°tica para Flask-SQLAlchemy

    # DPR_ADMIN_ENABLE_DB_FEATURES = _safe_cast_env("DPR_ADMIN_ENABLE_DB_FEATURES", False, bool) # Ex: Flag para habilitar features que requerem DB
    # if DPR_ADMIN_ENABLE_DB_FEATURES and (config_data["SQLALCHEMY_DATABASE_URI"] is None or _is_insecure_placeholder(config_data["SQLALCHEMY_DATABASE_URI"])):
    #      app_logger.fatal("DPR_CONFIG_FATAL: Features de Admin baseadas em DB habilitadas, mas DATABASE_URL n√£o configurada com valor seguro.")
    #      critical_configs_valid = False


    # --- CONFIGURA√á√ïES DE SEGURAN√áA ADICIONAIS ---
    # DPR_ADMIN_2FA_SECRET √© cr√≠tico SE REQUIRE_ADMIN_2FA for True
    config_data["DPR_ADMIN_2FA_SECRET"] = _safe_cast_env("DPR_ADMIN_2FA_SECRET", None, str, is_critical=False) # Not critical if 2FA is not required
    config_data["REQUIRE_ADMIN_2FA"] = _safe_cast_env("REQUIRE_ADMIN_2FA", False, bool)
    if config_data["REQUIRE_ADMIN_2FA"] and (config_data["DPR_ADMIN_2FA_SECRET"] is None or _is_insecure_placeholder(config_data["DPR_ADMIN_2FA_SECRET"])):
         app_logger.fatal("DPR_CONFIG_FATAL: REQUIRE_ADMIN_2FA √© True, mas DPR_ADMIN_2FA_SECRET n√£o configurado com valor seguro.")
         critical_configs_valid = False

    # DPR_DATA_ENCRYPTION_KEY √© cr√≠tica SE houver dados sens√≠veis persistidos NO BACKEND que precisam ser criptografados.
    # Sua criticidade depende da Tua modelagem de dados e compliance. Assumindo n√£o cr√≠tico por padr√£o, mas com forte aviso.
    config_data["DPR_DATA_ENCRYPTION_KEY"] = _safe_cast_env("DPR_DATA_ENCRYPTION_KEY", None, str, is_critical=False)
    if config_data["DPR_DATA_ENCRYPTION_KEY"] is None or _is_insecure_placeholder(config_data["DPR_DATA_ENCRYPTION_KEY"]):
         app_logger.warning("DPR_CONFIG_WARN: DPR_DATA_ENCRYPTION_KEY n√£o configurada com valor seguro. Dados sens√≠veis em repouso PODEM N√ÉO ESTAR CRIPTOGRAFADOS. Risco de compliance.")
         # N√£o fatal aqui, mas requer aten√ß√£o para compliance.

    # DPR_DATA_ANON_SALT √© cr√≠tico SE a anonimiza√ß√£o/pseudonimiza√ß√£o segura for mandat√≥ria para compliance (LGPD).
    # Sua criticidade depende da Tua modelagem de dados e compliance. Assumindo n√£o cr√≠tico por padr√£o, mas com forte aviso.
    config_data["DPR_DATA_ANON_SALT"] = _safe_cast_env("DPR_DATA_ANON_SALT", None, str, is_critical=False)
    if config_data["DPR_DATA_ANON_SALT"] is None or _is_insecure_placeholder(config_data["DPR_DATA_ANON_SALT"]):
         app_logger.warning("DPR_CONFIG_WARN: DPR_DATA_ANON_SALT n√£o configurado com valor seguro. Anonimiza√ß√£o/Pseudonimiza√ß√£o PODE N√ÉO SER SEGURA. Risco de compliance.")
         # N√£o fatal aqui, mas requer aten√ß√£o para compliance.

    # SENTRY_DSN: Cr√≠tico se monitoramento de erros remoto for um requisito de produ√ß√£o.
    config_data["SENTRY_DSN"] = _safe_cast_env("SENTRY_DSN", None, str, is_critical=False) # Deixar n√£o cr√≠tico por padr√£o, mas loga se configurado

    # --- PROPRIEDADES DO SISTEMA ---
    # Estes s√£o metadados, n√£o segredos, mas importantes para identifica√ß√£o.
    config_data["DPR_SYSTEM_PROPS"] = {
        "code_uid": "DPR-REGENERA-BACKEND-IMPERIAL-V10.10.FINAL-PROD",
        "version": "REGENERA A.I.¬Æ Backend - EDI√á√ÉO SOBERANA IMPERIAL DEFINITIVA - V10.10",
        "copyright": "Copyright ¬© 2024-2025 Paulo Ricardo de Le√£o. Todos os direitos reservados e ativamente defendidos.",
        "proprietario": "Paulo Ricardo de Le√£o",
        "nie_rg": "Y9562906-A / 2098233287",
        "identidade_visual": "REGENERA A.I.¬Æ - Marca Registrada. Elementos Visuais Propriet√°rios: Cores (Ouro Imperial Radiante Hex #C9A85B, Safira Real Profunda Hex #0F52BA, Platina Qu√¢ntica Transcendental Hex #E5E4E2, Negro Absoluto Hex #000000), Tipografia Exclusiva (DPR Sovereign Sans Gold, DPR Imperial Serif Lux, DPR Quantum Script), S√≠mbolo Registrado (Le√£o Alado Ascendente Coroado).",
        "domain": "www.regenerai.dprgoldstandard.com",
        "ssl_status": "Sistema operando sob Certificado SSL/TLS de Valida√ß√£o Extendida (EV) de N√≠vel Militar Avan√ßado. Todas as comunica√ß√µes s√£o fortificadas com criptografia.",
        "blockchain_nft_uid": f"DPR-REGENERA-IMPERIAL-V10.10-NFT-AUTENTICIDADE-PROD-TOKEN-{secrets.token_hex(32).upper()}",
        "uptime_start_utc": datetime.datetime.now(timezone.utc).isoformat(),
        "dpr_legal_statement_summary": "DECLARA√á√ÉO DE DIREITOS E PROPRIEDADE: Esta Intelig√™ncia Artificial (REGENERA A.I.¬Æ), em todas as suas manifesta√ß√µes, √© uma cria√ß√£o REAL e um ativo de PROPRIEDADE INTELECTUAL de Paulo Ricardo de Le√£o. O C√≥digo-Source, os Algoritmos Propriet√°rios, os Modelos de IA Treinados (incluindo a Voz Exclusiva DPR¬Æ), e toda a arquitetura tecnol√≥gica subjacente s√£o 100% PROPRIET√ÅRIOS, desenvolvidos sob a licen√ßa exclusiva e supervis√£o direta de Paulo Ricardo de Le√£o. Qualquer forma de acesso n√£o autorizado, uso indevido, intera√ß√£o n√£o licenciada, c√≥pia, deriva√ß√£o, engenharia reversa, ou qualquer viola√ß√£o dos direitos de Paulo Ricardo de Le√£o sobre esta cria√ß√£o, por quaisquer meios ou entidades, ser√° considerada uma transgress√£o direta. Tais atos ativar√£o contramedidas de seguran√ßa digital e resultar√£o em a√ß√µes legais implac√°veis nas mais altas cortes de jurisdi√ß√£o. A JUSTI√áA DE PAULO RICARDO DE LE√ÉO √â ABSOLUTA E INESCAP√ÅVEL.",
        "contact_enterprise_gold_support": "support.gold@dpr-sovereign.ai",
        "infra_details": "Hospedado em Data Centers Propriet√°rios com Seguran√ßa F√≠sica e Digital de Alto N√≠vel, Geo-redund√¢ncia Distribu√≠da e Prote√ß√£o contra Eventos Eletromagn√©ticos."
    }

    # Carregar EULA e Manifesto de arquivos (assumindo que est√£o em /app/app/assets ou caminhos de fallback)
    config_data["DPR_EULA_TEXT"] = _load_text_asset("eula_imperial_dpr_v10.txt", "[CONTRATO DE LICEN√áA DE USU√ÅRIO FINAL N√ÉO CARREGADO - ALERTA DE INTEGRIDADE SIST√äMICA! VERIFICAR IMEDIATAMENTE: app/assets/eula_imperial_dpr_v10.txt]")
    config_data["DPR_MANIFESTO_TEXT"] = _load_text_asset("manifesto_soberano_regenerai_v10.txt", "[MANIFESTO DE SOBERANIA E AUTENTICIDADE N√ÉO CARREGADO - ALERTA DE INTEGRIDADE DOUTRIN√ÅRIA! VERIFICAR IMEDIATAMENTE: app/assets/manifesto_soberano_regenerai_v10.txt]")
    
    # Outras Configura√ß√µes
    config_data["DPR_SIGNATURE_FOOTER"] = "\n\n# REGENERA A.I.¬Æ - Edi√ß√£o Soberana Imperial Definitiva. Autenticidade e Poder Digital por Paulo Ricardo de Le√£o. Todos os Direitos Reservados. #"
    config_data["DPR_IA_NAME"] = "REGENERA A.I.¬Æ (Edi√ß√£o Soberana Imperial Definitiva V10.10)"


    # Define a flag de validade cr√≠tica final
    config_data["CRITICAL_CONFIG_VALID"] = critical_configs_valid

    if not critical_configs_valid:
        app_logger.fatal("DPR_CONFIG_VALIDATION_OVERALL_FAILURE: Uma ou mais configura√ß√µes CR√çTICAS do sistema REGENERA A.I.¬Æ n√£o foram definidas corretamente com valores seguros ou cont√™m placeholders. O sistema N√ÉO PODE INICIAR ou operar de forma segura. VERIFIQUE OS LOGS CR√çTICOS ANTERIORES E CORRIJA TODAS AS CONFIGURA√á√ïES MARCADAS COMO 'FATAL' ANTES DE TENTAR NOVAMENTE. A SOBERANIA E INTEGRIDADE DO SISTEMA DEPENDEM DISSO.")
        # N√£o levanta exce√ß√£o aqui, a checagem no wsgi.py far√° isso.
    else:
        app_logger.info(f"DPR_CONFIG: Configura√ß√£o Enterprise (Vers√£o: {config_data['DPR_SYSTEM_PROPS']['version']}) carregada e validada com sucesso.")

    return config_data

# ==========¬©====DON=====¬Æ==========
# FIM DO ARQUIVO app/core/config.py
# SELADO SOB AUTORIDADE DPR.
```
```python
# -*- coding: utf-8 -*-
#
# üúÇ REGENERA A.I.¬Æ BACKEND - EDI√á√ÉO SOBERANA IMPERIAL DEFINITIVA V10.10 üúÇ
# üúÑ ARQUIVO: app/utils/logging_config.py üúÑ
#
# M√≥dulo de Configura√ß√£o de Logging Estruturado para Auditoria.
# Desenvolvido por Paulo Ricardo de Le√£o.
#
# Este m√≥dulo configura o sistema de logging para garantir que todos os eventos relevantes,
# especialmente aqueles com implica√ß√µes de seguran√ßa e auditoria, sejam registrados de forma
# estruturada (JSON) e roteados para destinos apropriados (console, arquivo, SIEM).
#
# Logs de n√≠vel CRITICAL e FATAL indicam falhas de seguran√ßa ou integridade que exigem aten√ß√£o imediata.
# Logs de n√≠vel ERROR indicam problemas operacionais que afetam a funcionalidade.
# Logs de n√≠vel WARNING indicam condi√ß√µes potencialmente problem√°ticas.
# Logs de n√≠vel INFO registram opera√ß√µes normais e eventos de seguran√ßa importantes (login, acesso).
# Logs de n√≠vel DEBUG s√£o para depura√ß√£o detalhada (N√ÉO USAR EM PRODU√á√ÉO).
#
# ==========¬©====DON=====¬Æ==========

import logging
import sys
import json
import datetime
from datetime import timezone
import os

# --- FORMATADOR DE LOG ESTRUTURADO JSON ---
class JsonFormatterDPR(logging.Formatter):
    """
    Formatador de log que produz sa√≠da em formato JSON estruturado,
    incluindo metadados customizados e timestamp UTC.
    """
    def format(self, record):
        # Captura metadados padr√£o do record
        log_record = {
            "timestamp_utc": datetime.datetime.fromtimestamp(record.created, tz=timezone.utc).isoformat(),
            "level": record.levelname,
            "logger": record.name,
            "message": record.getMessage(),
            "pathname": record.pathname,
            "funcName": record.funcName,
            "lineno": record.lineno,
            "process": record.process,
            "thread": record.thread,
            # Adicionar metadados customizados se presentes no record
            "dpr_metadata": getattr(record, 'dpr_metadata', {})
        }

        # Incluir informa√ß√µes de exce√ß√£o se presentes
        if record.exc_info:
            log_record["exc_info"] = self.formatException(record.exc_info)
        if record.stack_info:
            log_record["stack_info"] = self.formatStack(record.stack_info)

        # Adicionar quaisquer outros atributos customizados que n√£o comecem com '_'
        for key, value in record.__dict__.items():
            if not key.startswith('_') and key not in log_record and key != 'dpr_metadata':
                 # Evitar serializar objetos complexos, focar em tipos b√°sicos ou representa√ß√µes string
                 try:
                     json.dumps(value) # Testa se √© serializ√°vel
                     log_record[key] = value
                 except (TypeError, OverflowError):
                     log_record[key] = repr(value) # Usa representa√ß√£o string se n√£o serializ√°vel

        return json.dumps(log_record, ensure_ascii=False)

# --- HANDLER DE LOG PARA ARQUIVO DE AUDITORIA ---
class AuditFileHandler(logging.FileHandler):
    """
    Handler de log que escreve logs em um arquivo espec√≠fico para auditoria.
    Garante que o diret√≥rio de log exista e define permiss√µes seguras.
    """
    def __init__(self, filename, mode='a', encoding=None, delay=False, errors=None):
        log_dir = os.path.dirname(filename)
        if log_dir and not os.path.exists(log_dir):
            try:
                os.makedirs(log_dir, exist_ok=True)
                # Definir permiss√µes seguras para o diret√≥rio (apenas propriet√°rio)
                try:
                    os.chmod(log_dir, 0o700)
                except Exception as e:
                     sys.stderr.write(f"DPR_LOG_INIT_ERROR: Falha ao definir permiss√µes seguras para o diret√≥rio de log '{log_dir}': {e}\n")

            except Exception as e:
                # Log para stderr se falhar a cria√ß√£o do diret√≥rio de log
                sys.stderr.write(f"DPR_LOG_INIT_ERROR: Falha cr√≠tica ao criar diret√≥rio de log de auditoria '{log_dir}': {e}\n")
                # Fallback para stdout/stderr se n√£o conseguir escrever em arquivo
                filename = None # Impede a cria√ß√£o do handler de arquivo
                # Cria um handler que escreve para stderr como fallback
                super().__init__(sys.stderr.fileno(), mode, encoding, delay, errors)
                return

        # Tenta abrir o arquivo e definir permiss√µes seguras
        try:
            super().__init__(filename, mode, encoding, delay, errors)
            # Tentar definir permiss√µes ap√≥s a cria√ß√£o do arquivo
            if os.path.exists(filename):
                 try:
                     os.chmod(filename, 0o600) # Apenas propriet√°rio pode ler/escrever o arquivo de log
                 except Exception as e:
                      sys.stderr.write(f"DPR_LOG_INIT_ERROR: Falha ao definir permiss√µes seguras para o arquivo de log '{filename}': {e}\n")

            sys.stdout.write(f"DPR_LOG_INIT: Configurado handler de log de auditoria para '{filename}'.\n")
        except Exception as e:
            # Se a base FileHandler.__init__ falhar (ex: permiss√µes de arquivo),
            # garantimos um fallback para stderr.
            sys.stderr.write(f"DPR_LOG_INIT_ERROR: Falha cr√≠tica ao inicializar handler de arquivo de auditoria '{filename}': {e}\n")
            # Cria um handler que escreve para stderr como fallback final
            super().__init__(sys.stderr.fileno(), mode, encoding, delay, errors)


# --- FUN√á√ÉO DE CONFIGURA√á√ÉO CENTRALIZADA DO LOGGER ---
def setup_logging(log_level_str="INFO", log_file_path="/app/logs_dpr_regenera/regenerai_audit.log"):
    """
    Configura o sistema de logging para a aplica√ß√£o REGENERA A.I.¬Æ.
    Define formatadores e handlers para console e arquivo de auditoria.
    """
    # Mapeia string de n√≠vel para constante de logging
    log_level = getattr(logging, log_level_str.upper(), logging.INFO)

    # Configura o logger raiz
    root_logger = logging.getLogger()
    root_logger.setLevel(log_level)

    # Evita handlers duplicados em recargas (√∫til em ambientes de desenvolvimento)
    if root_logger.handlers:
        for handler in root_logger.handlers:
            root_logger.removeHandler(handler)

    # --- Handlers ---
    # Handler para console (stdout) - para monitoramento imediato
    console_handler = logging.StreamHandler(sys.stdout)
    console_formatter = JsonFormatterDPR() # Usar JSON tamb√©m para console em produ√ß√£o
    console_handler.setFormatter(console_formatter)
    console_handler.setLevel(log_level) # Console pode ter n√≠vel diferente se necess√°rio
    root_logger.addHandler(console_handler)

    # Handler para arquivo de auditoria (JSON)
    try:
        file_handler = AuditFileHandler(log_file_path)
        file_formatter = JsonFormatterDPR()
        file_handler.setFormatter(file_formatter)
        file_handler.setLevel(logging.INFO) # Logs de auditoria devem capturar INFO e acima
        root_logger.addHandler(file_handler)
        # Log inicial para confirmar configura√ß√£o
        logging.info("DPR_LOG_INIT: Logging configurado com sucesso. N√≠vel: %s, Arquivo Auditoria: %s", log_level_str, log_file_path)
    except Exception as e:
         # AuditFileHandler j√° loga para stderr se falhar.
         # Logamos aqui apenas para garantir que um registro da falha aparece no console principal.
         logging.error(f"DPR_LOG_INIT_ERROR: N√£o foi poss√≠vel configurar o handler de arquivo de auditoria (detalhes no stderr): {e!s}. Logs ser√£o enviados apenas para o console.", exc_info=True)


# --- FUN√á√ÉO PARA LOG DE AUDITORIA COM METADADOS CUSTOMIZADOS ---
def log_audit(level, message, user_id="N/A", device_id="N/A", request_id="N/A", event_type="GENERIC_EVENT", **kwargs):
    """
    Fun√ß√£o utilit√°ria para logar eventos com metadados espec√≠ficos para auditoria.
    Permite adicionar contexto de seguran√ßa e auditoria aos logs estruturados.
    Args:
        level (int): N√≠vel de logging (ex: logging.INFO, logging.ERROR).
        message (str): A mensagem principal do log.
        user_id (str): ID do usu√°rio associado ao evento.
        device_id (str): ID do dispositivo associado ao evento.
        request_id (str): ID √∫nico da requisi√ß√£o HTTP associada (se aplic√°vel).
        event_type (str): Categoria estruturada do evento (ex: "AUTH_SUCCESS", "IA_ERROR", "INTEGRITY_VIOLATION").
        **kwargs: Metadados adicionais espec√≠ficos do evento (ser√£o inclu√≠dos em 'dpr_metadata').
    """
    # Adiciona metadados customizados ao dicion√°rio extra
    custom_metadata = {
        "dpr_user_id": user_id,
        "dpr_device_id": device_id,
        "dpr_request_id": request_id,
        "dpr_event_type": event_type,
        **kwargs # Inclui metadados adicionais passados via **kwargs
    }

    # Cria um logger nomeado espec√≠fico para logs de auditoria
    # Usar um logger nomeado ('DPR_AUDIT') permite roteamento seletivo via configura√ß√£o de logging mais avan√ßada
    logger = logging.getLogger("DPR_AUDIT")

    # Loga a mensagem com o n√≠vel especificado e os metadados no dicion√°rio 'extra'
    # O JsonFormatterDPR ir√° extrair 'dpr_metadata' e outros campos de 'extra'
    logger.log(level, message, extra={'dpr_metadata': custom_metadata})

# Exemplo de uso:
# log_audit(logging.INFO, "Authentication successful", user_id="user123", device_id="deviceXYZ", request_id="reqABC", event_type="AUTH_SUCCESS")
# log_audit(logging.WARNING, "Attempted unauthorized access", user_id="anonymous", device_id="unknown", request_id="reqDEF", event_type="ACCESS_DENIED", reason="UNAUTHORIZED", path="/api/v10/ia/generate_text", method="POST", ip_address="192.168.1.1")
# log_audit(logging.CRITICAL, "Code integrity verification failed", event_type="INTEGRITY_CHECK_FAILED", expected_hash="...", calculated_hash="...")
# log_audit(logging.INFO, "API Request Received", event_type="API_REQUEST", endpoint="/api/v10/ia/generate_text", user_id="user123", device_id="deviceXYZ", request_id="reqABC")


# ==========¬©====DON=====¬Æ==========
# FIM DO ARQUIVO app/utils/logging_config.py
# SELADO SOB AUTORIDADE DPR.
```
```python
# -*- coding: utf-8 -*-
#
# üúÇ REGENERA A.I.¬Æ BACKEND - EDI√á√ÉO SOBERANA IMPERIAL DEFINITIVA V10.10 üúÇ
# üúÑ ARQUIVO: app/utils/data_processing.py üúÑ
#
# M√≥dulo de Utilit√°rios de Processamento de Dados.
# Desenvolvido por Paulo Ricardo de Le√£o.
#
# Inclui fun√ß√µes para anonimiza√ß√£o/pseudonimiza√ß√£o e tratamento de solicita√ß√µes de dados,
# conforme protocolos de compliance (LGPD/GDPR), refor√ßando a seguran√ßa e privacidade.
#
# ==========¬©====DON=====¬Æ==========

import hashlib
import datetime
from datetime import timezone
import logging
import json # Para serializar request_params_hashed
from cryptography.fernet import Fernet # Para criptografia de dados em repouso
import os # Para acessar env vars (SALT, KEY)
import secrets # Para gerar IDs √∫nicos (se necess√°rio)

# Assuming log_audit is correctly configured and imported
from app.utils.logging_config import log_audit


app_logger = logging.getLogger("DPR_DATA_PROCESSING")

# --- CRIPTOGRAFIA/DECRIPTOGRAFIA DE DADOS EM REPOUSO ---
# Requer Fernet (j√° inclu√≠do em cryptography) e uma chave Fernet segura.
# A chave Fernet DEVE ser gerida como um segredo CR√çTICO (DPR_DATA_ENCRYPTION_KEY).

_FERNET_CIPHER = None

def initialize_encryption(fernet_key_b64):
    """Inicializa a cifra Fernet para criptografia de dados em repouso."""
    global _FERNET_CIPHER
    if fernet_key_b64:
        try:
            # Chave Fernet precisa ser bytes URL-safe Base64
            _FERNET_CIPHER = Fernet(fernet_key_b64.encode('utf-8'))
            app_logger.info("DPR_DATA_PROCESSING: Cifra Fernet inicializada para criptografia de dados em repouso.")
        except Exception as e:
             app_logger.critical(f"DPR_DATA_PROCESSING_FATAL: Falha ao inicializar cifra Fernet: {e!s}. Criptografia de dados em repouso inoperante.", exc_info=True)
             _FERNET_CIPHER = None
    else:
         app_logger.warning("DPR_DATA_PROCESSING_WARN: DPR_DATA_ENCRYPTION_KEY n√£o configurada. Criptografia de dados em repouso n√£o dispon√≠vel.")
         _FERNET_CIPHER = None # Garante que √© None se a chave n√£o est√° configurada

def encrypt_sensitive_data(data_bytes):
    """Criptografa dados sens√≠veis usando Fernet."""
    if _FERNET_CIPHER:
        try:
            encrypted_data = _FERNET_CIPHER.encrypt(data_bytes)
            return encrypted_data
        except Exception as e:
             app_logger.error(f"DPR_DATA_PROCESSING_ERROR: Falha na criptografia de dados: {e!s}", exc_info=True)
             # Decida a pol√≠tica de seguran√ßa aqui: falhar a opera√ß√£o, armazenar sem criptografia (risco!), etc.
             # Para um sistema seguro, FALHAR seria o mais apropriado.
             raise RuntimeError(f"Falha na criptografia de dados: {e!s}")
    else:
         app_logger.warning("DPR_DATA_PROCESSING_WARN: Tentativa de criptografar dados, mas a cifra Fernet n√£o est√° dispon√≠vel.")
         raise RuntimeError("Criptografia n√£o dispon√≠vel.")

def decrypt_sensitive_data(encrypted_data_bytes):
    """Decriptografa dados sens√≠veis usando Fernet."""
    if _FERNET_CIPHER:
        try:
            decrypted_data = _FERNET_CIPHER.decrypt(encrypted_data_bytes)
            return decrypted_data
        except Exception as e:
             app_logger.error(f"DPR_DATA_PROCESSING_ERROR: Falha na decriptografia de dados: {e!s}", exc_info=True)
             # Falhar na opera√ß√£o de leitura/processamento √© o mais seguro.
             raise RuntimeError(f"Falha na decriptografia de dados: {e!s}")
    else:
         app_logger.warning("DPR_DATA_PROCESSING_WARN: Tentativa de decriptografar dados, mas a cifra Fernet n√£o est√° dispon√≠vel.")
         raise RuntimeError("Decriptografia n√£o dispon√≠vel.")


# --- FUN√á√ÉO DE ANONIMIZA√á√ÉO/PSEUDONIMIZA√á√ÉO DE DADOS SENS√çVEIS ---
def anonymize_data(raw_data: dict, identifier_fields: list = ["user_id", "device_id", "ip_address"], content_fields: list = ["input_text", "output_text", "audio_content", "image_data_url", "user_name", "email"]) -> dict:
    """
    Anonimiza ou pseudonimiza dados sens√≠veis em um dicion√°rio.

    Args:
        raw_data (dict): O dicion√°rio contendo dados brutos, potencialmente sens√≠veis.
        identifier_fields (list): Lista de chaves cujos valores devem ser hashados (pseudonimiza√ß√£o).
        content_fields (list): Lista de chaves cujo conte√∫do deve ser redigido ou removido.

    Returns:
        dict: Um novo dicion√°rio com dados anonimizados/pseudonimizados.

    Nota: Esta √© uma implementa√ß√£o conceitual.
    A anonimiza√ß√£o/pseudonimiza√ß√£o REAL DEVE seguir protocolos estritos e usar
    t√©cnicas adequadas (ex: tokeniza√ß√£o segura com chave de sal rotativa,
    criptografia homom√≥rfica) e ser validada por especialistas em compliance (LGPD/GDPR, HIPAA).
    Dados de modelos de IA e treinamento REQUEREM TRATAMENTO ESPECIAL E SEGURO,
    frequentemente offline ou com t√©cnicas como Federated Learning.
    """
    # Ensure we are working with a copy to avoid modifying the original dictionary
    anonymized_data = raw_data.copy() 

    # Obter salt para hashing seguro (se configurado)
    data_anon_salt = os.environ.get("DPR_DATA_ANON_SALT")
    if not data_anon_salt:
         app_logger.error("DPR_DATA_PROCESSING_ERROR: DPR_DATA_ANON_SALT n√£o configurado! Hashing de identificadores n√£o √© seguro/n√£o √© pseudonimiza√ß√£o real.")
         # Fallback para salt fixo inseguro (N√ÉO USE EM PRODU√á√ÉO) ou lan√ßa erro dependendo da pol√≠tica
         data_anon_salt = "INSECURE_DEFAULT_SALT_REPLACE_ME_IN_PROD" # Fallback inseguro para evitar crash

    # Pseudonymize identifiers (hashes)
    for field in identifier_fields:
        if field in anonymized_data and anonymized_data[field] is not None:
            try:
                # Use o salt configurado para salgar o hash
                salted_value = str(anonymized_data[field]).encode('utf-8') + data_anon_salt.encode('utf-8')
                hashed_value = hashlib.sha256(salted_value).hexdigest()
                
                anonymized_data[f"{field}_hashed"] = hashed_value
                # Only remove the original field if the hash was successful
                del anonymized_data[field] 
            except Exception as e:
                # Log hashing failure but still process other fields
                app_logger.error(f"DPR_DATA_PROCESSING_ERROR: Falha ao hashar campo '{field}' durante anonimiza√ß√£o: {e!s}", exc_info=True)
                anonymized_data[f"{field}_hashed"] = "HASH_ERROR"
                # Considerar se o campo original deve ser redigido ou mantido neste caso de erro. Padr√£o: redigir.
                anonymized_data[field] = "[REDACTION_FAILED]" # Redige para seguran√ßa se hash falhar
        # Handle cases where the field might be None or missing if necessary, based on your schema

    # Redact or mask sensitive content fields (this also covers some fields from identifier_fields list if present)
    fields_to_redact = set(identifier_fields + content_fields) # Redigir todos os campos sens√≠veis listados
    for field in fields_to_redact:
         # Evitar redigir campos que j√° foram hashados e removidos
         if field in anonymized_data: # Verifica se ainda est√° presente
              # Check if the field exists AND is not None before attempting to redact
              if anonymized_data[field] is not None:
                   anonymized_data[field] = "[CONTENT_REDACTED]"
              else: # Campo existe mas √© None
                   anonymized_data[field] = "[EMPTY_VALUE_REDACTED]"


    # Add audit metadata for anonymization process
    anonymized_data["dpr_anon_timestamp_utc"] = datetime.datetime.now(timezone.utc).isoformat()
    anonymized_data["dpr_anon_method"] = "SHA256_Salted_Hashing_and_Redaction_Conceptual" # Describe the actual method used in Production
    anonymized_data["dpr_anon_salt_status"] = "Configured" if data_anon_salt != "INSECURE_DEFAULT_SALT_REPLACE_ME_IN_PROD" else "Insecure_Default" # Loga o status do salt


    # TODO: Logar o evento de anonimiza√ß√£o no log de auditoria AP√ìS o processamento da opera√ß√£o principal.
    # log_audit(logging.INFO, "Dados anonimizados.", event_type="DATA_ANONYMIZED", ...)


    return anonymized_data


# --- TRATAMENTO DE SOLICITA√á√ïES DE DADOS (LGPD/GDPR - CONCEITUAL) ---

def process_data_request(request_type: str, request_params: dict, request_id="N/A"):
    """
    Processa solicita√ß√µes de direitos dos titulares de dados (acesso, corre√ß√£o, exclus√£o, etc.).

    Args:
        request_type (str): Tipo da solicita√ß√£o ("access", "correction", "erasure", etc.).
        request_params (dict): Par√¢metros da solicita√ß√£o (ex: "user_id", "email_proof", etc.).
        request_id (str): ID da requisi√ß√£o associada.

    Nota: Esta √© uma implementa√ß√£o altamente conceitual.
    Um sistema REAL para tratamento de direitos dos titulares DEVE:
    - Realizar Identifica√ß√£o SEGURA do solicitante (verifica√ß√£o de identidade robusta).
    - Buscar por TODOS os dados relacionados ao titular em TODOS os sistemas (estruturados/n√£o estruturados, logs, dados de infer√™ncia de IA, dados de treinamento).
    - Aplicar as a√ß√µes apropriadas (fornecimento dos dados em formato port√°til, corre√ß√£o, anonimiza√ß√£o IRREVERS√çVEL/dele√ß√£o segura).
    - Gerar comprovantes AUDIT√ÅVEIS da a√ß√£o realizada.
    - Gerenciar prazos (LGPD/GDPR tem prazos r√≠gidos).
    - Este processo interage profundamente com o sistema de armazenamento de dados e o sistema de Logging de Auditoria.
    """
    # Use log_audit para logar a recep√ß√£o da solicita√ß√£o para trilha de auditoria
    
    # Hash sensitive request parameters before logging the request details
    try:
        hashed_request_params = hashlib.sha256(json.dumps(request_params, sort_keys=True).encode('utf-8')).hexdigest()
    except Exception:
        hashed_request_params = "HASHING_ERROR" # Handle potential serialization issues
        
    log_audit(logging.INFO, f"Received data request: Type='{request_type}'.", event_type="DATA_REQUEST_RECEIVED", request_type=request_type, request_id=request_id, ip_address="N/A", # IP address might not be relevant here, depending on how request arrives
                     extra_metadata={'request_params_hash': hashed_request_params}) # Log a hash of the params


    # Exemplo: Solicita√ß√£o de Exclus√£o (Direito ao Esquecimento)
    if request_type == "erasure":
        user_identifier = request_params.get("user_id") # ID de usu√°rio ou outro identificador para lookup
        proof_of_identity = request_params.get("proof_of_identity") # Conceptual proof required

        if not user_identifier:
             app_logger.warning("DPR_DATA_PROCESSING_WARN: Erasure request failed: User identifier (user_id) is missing.")
             log_audit(logging.WARNING, "Data erasure request failed: User identifier missing.", event_type="DATA_REQUEST_FAILED", request_type="erasure", request_id=request_id, reason="IDENTIFIER_MISSING")
             return {"status": "error", "message": "DPR_DATA_PROCESSING_ERROR: User identifier (user_id) √© obrigat√≥rio para solicita√ß√µes de exclus√£o.", "code": "DPR_400_BAD_REQUEST"}
        
        # TODO: Implement SECURE identity verification using proof_of_identity
        # if not verify_identity(user_identifier, proof_of_identity):
        #      app_logger.warning(f"DPR_DATA_PROCESSING_WARN: Erasure request failed for user '{user_identifier[:8]}...': Identity verification failed.")
        #      log_audit(logging.WARNING, "Data erasure request failed: Identity verification failed.", event_type="DATA_REQUEST_FAILED", request_type="erasure", request_id=request_id, user_id_requested=user_identifier, reason="IDENTITY_VERIFICATION_FAILED")
        #      return {"status": "error", "message": "DPR_DATA_PROCESSING_ERROR: Identity verification failed.", "code": "DPR_401_UNAUTHORIZED"}


        app_logger.info(f"DPR_DATA_PROCESSING: Processing erasure request for user identifier: {user_identifier[:8]}...")
        log_audit(logging.INFO, "Initiating data erasure process.", event_type="DATA_ERASURE_INITIATED", request_type="erasure", request_id=request_id, user_id_requested=user_identifier)

        # TODO: Implement the REAL logic for searching and irreversibly anonymizing/deleting data
        # This is complex and requires deep integration with your data storage and model systems.
        # 1. Identify and Anonymize/Delete user data from the Database/Cache (historical features, trained model parameters if per-user).
        #    - Requires logic interacting with your DB/Cache layer.
        # 2. Anonymize or Redact relevant entries in the Audit Logs (using anonymize_data on log records themselves).
        #    - Requires access to the log storage and updating/re-signing immutable logs (advanced topic).
        # 3. Anonymize/Delete user data used in model training sets (requires re-training or secure data management of training data).
        #    - This is very challenging for large pre-trained models unless Federated Learning or similar privacy-preserving training methods are used.

        # Placeholder: Simulate the erasure process
        app_logger.info(f"DPR_DATA_PROCESSING: (Placeholder) Simulating data erasure for user identifier: {user_identifier[:8]}...")
        # Simulate processing time
        # time.sleep(2) # Add delay for realistic simulation

        # TODO: Log the completion status (success/failure) of the erasure process
        app_logger.info(f"DPR_DATA_PROCESSING_SUCCESS: Simulation of data erasure completed for identifier: {user_identifier[:8]}.")
        log_audit(logging.INFO, "Data erasure process simulated successfully.", event_type="DATA_ERASURE_COMPLETED_SIMULATED", request_type="erasure", request_id=request_id, user_id_requested=user_identifier, status="success_simulated")


        return {"status": "processing", "message": f"DPR_DATA_PROCESSING_STATUS: Sua solicita√ß√£o de exclus√£o de dados para o identificador '{user_identifier[:8]}...' foi recebida e o processo de anonimiza√ß√£o/dele√ß√£o irrevers√≠vel est√° em andamento. O prazo de conclus√£o segue protocolos de compliance. Favor aguardar a notifica√ß√£o final.", "code": "DPR_202_ACCEPTED"}


    # Exemplo: Solicita√ß√£o de Acesso (Direito de Acesso)
    elif request_type == "access":
         user_identifier = request_params.get("user_id")
         proof_of_identity = request_params.get("proof_of_identity") # Conceptual proof required

         if not user_identifier:
             app_logger.warning("DPR_DATA_PROCESSING_WARN: Access request failed: User identifier (user_id) is missing.")
             log_audit(logging.WARNING, "Data access request failed: User identifier missing.", event_type="DATA_REQUEST_FAILED", request_type="access", request_id=request_id, reason="IDENTIFIER_MISSING")
             return {"status": "error", "message": "DPR_DATA_PROCESSING_ERROR: User identifier (user_id) √© obrigat√≥rio para solicita√ß√µes de acesso.", "code": "DPR_400_BAD_REQUEST"}

         # TODO: Implement SECURE identity verification
         # if not verify_identity(user_identifier, proof_of_identity):
         #      app_logger.warning(...)
         #      log_audit(...)
         #      return {... DPR_401_UNAUTHORIZED ...}


         app_logger.info(f"DPR_DATA_PROCESSING: Processing access request for user identifier: {user_identifier[:8]}...")
         log_audit(logging.INFO, "Initiating data access process.", event_type="DATA_ACCESS_INITIATED", request_type="access", request_id=request_id, user_id_requested=user_identifier)

         # TODO: Implement the REAL logic to collect all data related to this user
         # - Collect profile data, interaction history (if stored in non-anonymized form, e.g., logs BEFORE anonymization).
         # - Collect data inputs/outputs used for inference (requires secure audit logs or database).
         # - Access data from the Sanctuary (user-specific quantum/classical representations).
         # - Format the data in a readable and secure way for delivery to the data subject.

         # Placeholder: Simulate data collection and preparation
         app_logger.info(f"DPR_DATA_PROCESSING: (Placeholder) Simulating data collection for user identifier: {user_identifier[:8]}...")
         # Simulate processing time
         # time.sleep(3) # Add delay for realistic simulation

         # TODO: Log the completion status (success/failure) of the access process
         app_logger.info(f"DPR_DATA_PROCESSING_SUCCESS: Simulation of data collection completed for identifier: {user_identifier[:8]}.")
         log_audit(logging.INFO, "Data access process simulated successfully.", event_type="DATA_ACCESS_COMPLETED_SIMULATED", request_type="access", request_id=request_id, user_id_requested=user_identifier, status="success_simulated")


         return {"status": "processing", "message": f"DPR_DATA_PROCESSING_STATUS: Sua solicita√ß√£o de acesso a dados para o identificador '{user_identifier[:8]}...' foi recebida e a coleta est√° em andamento. Seus dados ser√£o preparados para entrega em formato estruturado, seguindo protocolos. Favor aguardar a notifica√ß√£o final com instru√ß√µes de acesso seguro.", "code": "DPR_202_ACCEPTED"}
    
    # TODO: Implement other request types (correction, portability, objection, etc.)
    # Each requires specific logic for searching, verifying, and processing data in your systems.


    else:
        # Unknown request type
        app_logger.warning(f"DPR_DATA_PROCESSING_WARN: Unknown data request type received: '{request_type}'")
        log_audit(logging.WARNING, f"Unknown data request: Type '{request_type}'.", event_type="DATA_REQUEST_FAILED", request_type="unknown", request_id=request_params.get("request_id"), reason="UNKNOWN_REQUEST_TYPE")
        return {"status": "error", "message": f"DPR_DATA_PROCESSING_ERROR: Tipo de solicita√ß√£o de dados '{request_type}' n√£o suportado. Contate o suporte.", "code": "DPR_400_BAD_REQUEST"}


# ==========¬©====DON=====¬Æ==========
# FIM DO ARQUIVO app/utils/data_processing.py
# SELADO SOB AUTORIDADE DPR.
```
```python
# -*- coding: utf-8 -*-
#
# üúÇ REGENERA A.I.¬Æ BACKEND - EDI√á√ÉO SOBERANA IMPERIAL DEFINITIVA V10.10 üúÇ
# üúÑ ARQUIVO: app/lib/integrity_verifier.py üúÑ
#
# M√≥dulo de Verifica√ß√£o de Integridade do C√≥digo.
# Desenvolvido por Paulo Ricardo de Le√£o.
#
# Este m√≥dulo implementa a verifica√ß√£o de integridade do c√≥digo-fonte
# nos diret√≥rios essenciais (`app/app`, `app/lib`, `app/models/proprietary`)
# no momento da inicializa√ß√£o. Calcula o hash SHA256 dos arquivos nestes diret√≥rios
# e compara com o hash esperado configurado (DPR_EXPECTED_CODE_HASH).
# Qualquer discrep√¢ncia indica uma viola√ß√£o da integridade do c√≥digo e resulta
# em falha catastr√≥fica de inicializa√ß√£o.
#
# Esta √© uma camada CR√çTICA de seguran√ßa para garantir que o c√≥digo em execu√ß√£o
# √© a vers√£o aut√™ntica e n√£o foi adulterado.
#
# ==========¬©====DON=====¬Æ==========

import logging
import os
import hashlib
import sys
from app.utils.logging_config import log_audit # Importa o logger de auditoria

app_logger = logging.getLogger("DPR_INTEGRITY_VERIFIER")

class IntegrityVerifier:
    """
    Verificador de integridade do c√≥digo-fonte.
    """
    _verified = False # Status de verifica√ß√£o global
    _expected_hash = None
    _last_hash = None

    def __init__(self, config):
        """
        Inicializa o verificador com o hash esperado da configura√ß√£o.
        """
        if not IntegrityVerifier._verified:
            IntegrityVerifier._expected_hash = config.get("DPR_EXPECTED_CODE_HASH")
            if not IntegrityVerifier._expected_hash:
                app_logger.fatal("DPR_INTEGRITY_FATAL: DPR_EXPECTED_CODE_HASH n√£o configurado. Verifica√ß√£o de integridade imposs√≠vel.")
                # N√£o define _verified como True para indicar falha na configura√ß√£o
            else:
                 app_logger.info("DPR_INTEGRITY: Verificador de integridade inicializado com hash esperado.")
                 # A verifica√ß√£o real acontece em verify_startup_integrity

    @staticmethod
    def _calculate_code_hash(directories=["/app/app", "/app/lib", "/app/models/proprietary"]):
        """
        Calcula o hash SHA256 combinado de todos os arquivos nos diret√≥rios especificados.
        Processa arquivos em ordem alfab√©tica para garantir consist√™ncia.
        """
        app_logger.info(f"DPR_INTEGRITY: Calculando hash de integridade para diret√≥rios: {directories}")
        hasher = hashlib.sha256()
        file_paths = []
        
        # Coleta todos os caminhos de arquivo em ordem alfab√©tica
        for directory in directories:
            if not os.path.isdir(directory):
                app_logger.warning(f"DPR_INTEGRITY_WARN: Diret√≥rio de integridade n√£o encontrado: {directory}. Ignorando.")
                continue
            for root, _, files in os.walk(directory):
                for file in sorted(files): # Ordena arquivos para hash consistente
                    file_paths.append(os.path.join(root, file))

        file_paths.sort() # Ordena caminhos completos tamb√©m

        # Atualiza o hasher com o conte√∫do de cada arquivo
        for file_path in file_paths:
            try:
                with open(file_path, 'rb') as f:
                    while True:
                        chunk = f.read(4096) # L√™ em chunks para arquivos grandes
                        if not chunk:
                            break
                        hasher.update(chunk)
                app_logger.debug(f"DPR_INTEGRITY_HASH: Processado arquivo: {file_path}")
            except FileNotFoundError:
                app_logger.error(f"DPR_INTEGRITY_ERROR: Arquivo esperado para hash n√£o encontrado: {file_path}. Integridade comprometida.")
                return None # Falha se um arquivo esperado n√£o for encontrado
            except Exception as e:
                app_logger.error(f"DPR_INTEGRITY_ERROR: Erro ao ler arquivo para hash: {file_path}: {e!s}", exc_info=True)
                return None # Falha em caso de erro de leitura

        calculated_hash = hasher.hexdigest()
        app_logger.info(f"DPR_INTEGRITY: Hash de integridade calculado: {calculated_hash}")
        return calculated_hash

    @classmethod
    def verify_startup_integrity(cls):
        """
        Verifica a integridade do c√≥digo no startup.
        Esta fun√ß√£o DEVE ser chamada no ponto de entrada da aplica√ß√£o (wsgi.py).
        Aborta a execu√ß√£o se a verifica√ß√£o falhar.
        """
        if cls._verified:
            app_logger.info("DPR_INTEGRITY: Verifica√ß√£o de integridade j√° realizada e bem-sucedida.")
            return True

        if cls._expected_hash is None:
            app_logger.fatal("DPR_INTEGRITY_FATAL: DPR_EXPECTED_CODE_HASH n√£o configurado durante a inicializa√ß√£o do verificador. N√£o √© poss√≠vel verificar a integridade.")
            log_audit(logging.CRITICAL, "Falha na verifica√ß√£o de integridade: DPR_EXPECTED_CODE_HASH ausente.", event_type="INTEGRITY_CHECK_FAILED", reason="CONFIG_MISSING")
            return False # Indica falha

        app_logger.info("DPR_INTEGRITY: Iniciando verifica√ß√£o de integridade do c√≥digo...")
        
        calculated_hash = cls._calculate_code_hash()

        if calculated_hash is None:
            app_logger.fatal("DPR_INTEGRITY_FATAL: Falha no c√°lculo do hash de integridade. Poss√≠vel adultera√ß√£o ou erro de permiss√£o.")
            log_audit(logging.CRITICAL, "Falha no c√°lculo do hash de integridade.", event_type="INTEGRITY_CHECK_FAILED", reason="HASH_CALCULATION_ERROR")
            return False # Indica falha

        cls._last_hash = calculated_hash

        if calculated_hash == cls._expected_hash:
            app_logger.info("DPR_INTEGRITY_SUCCESS: Verifica√ß√£o de integridade do c√≥digo BEM-SUCEDIDA. O c√≥digo √© aut√™ntico.")
            log_audit(logging.INFO, "Verifica√ß√£o de integridade do c√≥digo bem-sucedida.", event_type="INTEGRITY_CHECK_SUCCESS", code_hash=calculated_hash)
            cls._verified = True
            return True
        else:
            app_logger.fatal(f"DPR_INTEGRITY_FATAL: FALHA na verifica√ß√£o de integridade do c√≥digo! Hash calculado '{calculated_hash}' N√ÉO CORRESPONDE ao hash esperado '{cls._expected_hash}'. O c√≥digo pode ter sido adulterado.")
            log_audit(logging.CRITICAL, "FALHA na verifica√ß√£o de integridade do c√≥digo! C√≥digo adulterado detectado.", event_type="INTEGRITY_VIOLATION", expected_hash=cls._expected_hash, calculated_hash=calculated_hash)
            # Em um sistema real, isso DEVE levar a um sys.exit(1) no wsgi.py
            return False # Indica falha

    @classmethod
    def is_verified(cls):
        """Retorna o status da √∫ltima verifica√ß√£o de integridade."""
        return cls._verified

    @classmethod
    def get_last_hash(cls):
        """Retorna o √∫ltimo hash calculado."""
        return cls._last_hash

# ==========¬©====DON=====¬Æ==========
# FIM DO ARQUIVO app/lib/integrity_verifier.py
# SELADO SOB AUTORIDADE DPR.
```
```python
# -*- coding: utf-8 -*-
#
# üúÇ REGENERA A.I.¬Æ BACKEND - EDI√á√ÉO SOBERANA IMPERIAL DEFINITIVA V10.10 üúÇ
# üúÑ ARQUIVO: app/lib/device_attestation.py üúÑ
#
# M√≥dulo de Verifica√ß√£o de Atestado de Dispositivo.
# Desenvolvido por Paulo Ricardo de Le√£o.
#
# Este m√≥dulo implementa a l√≥gica para verificar o atestado de dispositivo enviado
# pelos clientes. O atestado √© um payload assinado pela chave privada do dispositivo,
# contendo informa√ß√µes como Device ID, timestamp e um nonce.
#
# A verifica√ß√£o garante que a requisi√ß√£o prov√©m de um dispositivo confi√°vel,
# cujo Device ID est√° na lista permitida e cujo atestado √© criptograficamente v√°lido,
# n√£o expirado e usa um nonce √∫nico e recente.
#
# Depende da chave p√∫blica RSA do dispositivo configurada (DPR_ATTESTATION_PUBLIC_KEY).
# Utiliza Redis para cache distribu√≠do de nonces em ambientes com m√∫ltiplos workers.
#
# ==========¬©====DON=====¬Æ==========

import logging
import base64
import json
import time
import secrets
from datetime import datetime, timezone
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.exceptions import InvalidSignature
# Importar Redis se REDIS_URL estiver configurado
try:
    import redis
    REDIS_AVAILABLE = True
except ImportError:
    REDIS_AVAILABLE = False
    # app_logger.warning("DPR_ATTESTATION: Redis n√£o dispon√≠vel. Nonces ser√£o armazenados apenas em mem√≥ria (n√£o escal√°vel para m√∫ltiplos workers).")

from app.utils.logging_config import log_audit # Importa o logger de auditoria

app_logger = logging.getLogger("DPR_DEVICE_ATTESTATION")

# Configura√ß√µes de Nonce e Timestamp (ajust√°veis via config se necess√°rio)
NONCE_LIFETIME_SECONDS = 300 # Nonce v√°lido por 5 minutos
TIMESTAMP_TOLERANCE_SECONDS = 300 # Timestamp da atesta√ß√£o pode ter at√© 5 minutos de diferen√ßa do servidor

# --- NONCE STORE (Pode ser Redis ou mem√≥ria) ---
# Para m√∫ltiplos Gunicorn workers, _NONCE_STORE DEVE ser um cache distribu√≠do (Redis).
# Para um √∫nico worker, um dicion√°rio em mem√≥ria √© suficiente.
# A inicializa√ß√£o do Redis deve ser feita uma vez no startup da aplica√ß√£o.
_NONCE_STORE = {} # Fallback em mem√≥ria
_REDIS_CLIENT = None # Cliente Redis compartilhado

def initialize_attestation_cache(redis_url=None):
    """Inicializa o cliente Redis para cache de nonces se REDIS_URL estiver configurado."""
    global _REDIS_CLIENT
    if REDIS_AVAILABLE and redis_url:
        try:
            _REDIS_CLIENT = redis.from_url(redis_url, decode_responses=True)
            # Testar a conex√£o
            _REDIS_CLIENT.ping()
            app_logger.info("DPR_ATTESTATION_CACHE: Cliente Redis inicializado com sucesso para cache de nonces.")
        except redis.exceptions.ConnectionError as e:
            app_logger.error(f"DPR_ATTESTATION_CACHE_ERROR: Falha ao conectar ao Redis em {redis_url}: {e!s}. Usando cache em mem√≥ria.", exc_info=True)
            _REDIS_CLIENT = None
    elif REDIS_AVAILABLE and not redis_url:
         app_logger.warning("DPR_ATTESTATION_CACHE: REDIS_URL n√£o configurada. Usando cache de nonces em mem√≥ria (n√£o escal√°vel para m√∫ltiplos workers).")
    else:
         app_logger.warning("DPR_ATTESTATION_CACHE: Biblioteca Redis n√£o instalada. Usando cache de nonces em mem√≥ria (n√£o escal√°vel para m√∫ltiplos workers).")


class DeviceAttestation:
    """
    Gerencia a gera√ß√£o e verifica√ß√£o de atestados de dispositivo.
    """
    def __init__(self, config):
        """
        Inicializa o verificador de atestado com a chave p√∫blica configurada.
        """
        self.config = config
        self.public_key = None
        self.require_attestation = config.get("REQUIRE_ATTESTATION", False)
        pem_key_str = config.get("DPR_ATTESTATION_PUBLIC_KEY")

        if not self.require_attestation:
            app_logger.info("DPR_ATTESTATION: Atesta√ß√£o de dispositivo desabilitada globalmente pela configura√ß√£o.")
            return

        if not pem_key_str:
            app_logger.critical("DPR_ATTESTATION_FATAL: REQUIRE_ATTESTATION √© True, mas DPR_ATTESTATION_PUBLIC_KEY n√£o est√° configurada ou √© placeholder.")
            # A falha na configura√ß√£o cr√≠tica j√° foi logada em config.py, mas refor√ßamos aqui.
            raise ValueError("DPR_ATTESTATION_PUBLIC_KEY n√£o configurada ou insegura mas √© requerida.")
        
        try:
            self.public_key = serialization.load_pem_public_key(pem_key_str.encode())
            app_logger.info("DPR_ATTESTATION: Chave p√∫blica de atesta√ß√£o carregada com sucesso.")
        except Exception as e:
            app_logger.critical(f"DPR_ATTESTATION_FATAL: Falha ao carregar DPR_ATTESTATION_PUBLIC_KEY: {e!s}", exc_info=True)
            self.public_key = None
            raise ValueError(f"Falha ao carregar DPR_ATTESTATION_PUBLIC_KEY: {e!s}")

        # Inicializa o cache de nonces se ainda n√£o foi feito
        if _REDIS_CLIENT is None and REDIS_AVAILABLE:
             initialize_attestation_cache(config.get("REDIS_URL"))

        # Limpeza inicial de nonces expirados (apenas para cache em mem√≥ria)
        if _REDIS_CLIENT is None:
            self._cleanup_expired_nonces_memory()

    # --- Gerenciamento de Nonces (Mem√≥ria ou Redis) ---
    @staticmethod
    def _store_nonce(nonce):
        """Armazena um nonce com tempo de expira√ß√£o."""
        if _REDIS_CLIENT:
            try:
                _REDIS_CLIENT.setex(f"nonce:{nonce}", NONCE_LIFETIME_SECONDS, "active")
                app_logger.debug(f"DPR_ATTESTATION_CACHE: Nonce '{nonce[:8]}...' armazenado no Redis.")
            except Exception as e:
                app_logger.error(f"DPR_ATTESTATION_CACHE_ERROR: Falha ao armazenar nonce no Redis: {e!s}. Nonce pode n√£o ser √∫nico.", exc_info=True)
                # Fallback para mem√≥ria? N√£o, melhor falhar para garantir unicidade.
                raise RuntimeError("Falha no cache de nonces.")
        else:
            _NONCE_STORE[nonce] = time.time() + NONCE_LIFETIME_SECONDS
            app_logger.debug(f"DPR_ATTESTATION_CACHE: Nonce '{nonce[:8]}...' armazenado em mem√≥ria.")
            # Em mem√≥ria, a limpeza √© peri√≥dica, n√£o por item.

    @staticmethod
    def _validate_and_consume_nonce(nonce):
        """Valida se um nonce existe e n√£o expirou, e o remove (consome)."""
        if _REDIS_CLIENT:
            try:
                # GETSET retorna o valor atual e define um novo valor (ou None se n√£o existir)
                # Usamos GETDEL para obter o valor e deletar atomicamente
                status = _REDIS_CLIENT.getdel(f"nonce:{nonce}")
                if status == "active":
                    app_logger.debug(f"DPR_ATTESTATION_CACHE: Nonce '{nonce[:8]}...' validado e consumido do Redis.")
                    return True
                else:
                    app_logger.warning(f"DPR_ATTESTATION_CACHE: Nonce '{nonce[:8]}...' n√£o encontrado ou j√° consumido no Redis.")
                    return False
            except Exception as e:
                app_logger.error(f"DPR_ATTESTATION_CACHE_ERROR: Falha ao validar/consumir nonce no Redis: {e!s}. Poss√≠vel reuso de nonce.", exc_info=True)
                return False # Falha em caso de erro no cache
        else:
            # Cache em mem√≥ria
            current_time = time.time()
            expiration_time = _NONCE_STORE.get(nonce)

            if expiration_time is None:
                app_logger.warning(f"DPR_ATTESTATION_CACHE: Nonce '{nonce[:8]}...' desconhecido ou j√° utilizado/expirado (mem√≥ria).")
                return False
            
            if current_time > expiration_time:
                app_logger.warning(f"DPR_ATTESTATION_CACHE: Nonce '{nonce[:8]}...' expirado no momento da verifica√ß√£o (mem√≥ria).")
                if nonce in _NONCE_STORE: del _NONCE_STORE[nonce] # Limpa imediatamente
                return False
            
            del _NONCE_STORE[nonce] # Consome o nonce
            app_logger.debug(f"DPR_ATTESTATION_CACHE: Nonce '{nonce[:8]}...' validado e consumido da mem√≥ria.")
            return True

    @staticmethod
    def _cleanup_expired_nonces_memory():
        """Limpa nonces expirados do cache em mem√≥ria (n√£o necess√°rio para Redis)."""
        if _REDIS_CLIENT is None:
            current_time = time.time()
            expired_nonces = [n for n, exp_time in list(_NONCE_STORE.items()) if exp_time < current_time]
            for n in expired_nonces:
                if n in _NONCE_STORE:
                     del _NONCE_STORE[n]
            if expired_nonces:
                app_logger.debug(f"DPR_ATTESTATION_CACHE: Limpos {len(expired_nonces)} nonces expirados da mem√≥ria.")

    @staticmethod
    def generate_nonce():
        """Gera um novo nonce e o armazena."""
        nonce = secrets.token_hex(32)
        try:
            DeviceAttestation._store_nonce(nonce)
            app_logger.info(f"DPR_ATTESTATION: Nonce gerado e armazenado: {nonce[:8]}...")
            return nonce
        except Exception:
            app_logger.critical("DPR_ATTESTATION_FATAL: Falha ao gerar e armazenar nonce. Sistema de atesta√ß√£o inoperante.")
            return None # Indica falha na gera√ß√£o/armazenamento

    # --- Verifica√ß√£o de Atestado ---
    def _validate_timestamp(self, attestation_timestamp_str):
        """Valida se o timestamp da atesta√ß√£o est√° dentro da toler√¢ncia."""
        try:
            # Tenta converter de ISO 8601 ou timestamp num√©rico
            if isinstance(attestation_timestamp_str, (int, float)):
                attestation_ts = float(attestation_timestamp_str)
            elif isinstance(attestation_timestamp_str, str):
                # Adiciona timezone info se ausente (assume UTC se 'Z' ou '+00:00' n√£o estiver presente)
                if attestation_timestamp_str.endswith("Z"):
                    attestation_timestamp_str = attestation_timestamp_str[:-1] + "+00:00"
                elif "+" not in attestation_timestamp_str and "-" not in attestation_timestamp_str[11:]: # Heur√≠stica simples para offset
                     attestation_timestamp_str += "+00:00" # Assume UTC se n√£o houver offset
                
                attestation_ts = datetime.fromisoformat(attestation_timestamp_str).timestamp()
            else:
                raise ValueError("Formato de timestamp n√£o suportado.")

            current_ts = datetime.now(timezone.utc).timestamp()
            
            if abs(current_ts - attestation_ts) > TIMESTAMP_TOLERANCE_SECONDS:
                app_logger.warning(f"DPR_ATTESTATION_VALIDATION: Timestamp da atesta√ß√£o ({attestation_timestamp_str} -> {attestation_ts:.0f}) fora da toler√¢ncia. Delta: {abs(current_ts - attestation_ts):.0f}s, Toler√¢ncia: {TIMESTAMP_TOLERANCE_SECONDS}s.")
                log_audit(logging.WARNING, "Atestado rejeitado: Timestamp fora da toler√¢ncia.", event_type="ATTESTATION_FAILED", reason="TIMESTAMP_OUT_OF_TOLERANCE", attestation_ts=attestation_ts, server_ts=current_ts)
                return False
            app_logger.debug(f"DPR_ATTESTATION_VALIDATION: Timestamp da atesta√ß√£o ({attestation_timestamp_str}) validado.")
            return True
        except ValueError as e:
            app_logger.warning(f"DPR_ATTESTATION_VALIDATION: Formato de timestamp inv√°lido: {attestation_timestamp_str}. Erro: {e!s}")
            log_audit(logging.WARNING, "Atestado rejeitado: Formato de timestamp inv√°lido.", event_type="ATTESTATION_FAILED", reason="INVALID_TIMESTAMP_FORMAT", raw_timestamp=attestation_timestamp_str)
            return False

    def _verify_attestation_claims(self, claims, device_id):
        """
        Verifica claims espec√≠ficos dentro do payload de atestado.
        Implementar l√≥gica de valida√ß√£o de claims TEE/TPM aqui.
        Por enquanto, √© um placeholder que sempre retorna True.
        """
        app_logger.info(f"DPR_ATTESTATION_VALIDATION: Verificando claims (placeholder) de atestado para {device_id}: {claims}")
        # Exemplo: Verificar se 'secure_boot_enabled' √© True nos claims
        # if not claims.get("secure_boot_enabled", False):
        #     app_logger.warning(f"DPR_ATTESTATION_VALIDATION: Atestado para {device_id} indica Secure Boot desabilitado.")
        #     log_audit(logging.WARNING, "Atestado rejeitado: Secure Boot desabilitado.", event_type="ATTESTATION_FAILED", reason="SECURE_BOOT_DISABLED", device_id=device_id, claims=claims)
        #     return False
        
        # Exemplo: Verificar vers√£o do firmware TEE
        # required_tee_version = "1.2.3"
        # if claims.get("tee_firmware_version") != required_tee_version:
        #     app_logger.warning(f"DPR_ATTESTATION_VALIDATION: Atestado para {device_id} tem vers√£o de TEE inv√°lida: {claims.get('tee_firmware_version')}")
        #     log_audit(logging.WARNING, "Atestado rejeitado: Vers√£o de TEE inv√°lida.", event_type="ATTESTATION_FAILED", reason="INVALID_TEE_VERSION", device_id=device_id, claims=claims)
        #     return False

        # TODO: Implementar valida√ß√£o real dos claims de atestado TEE/TPM conforme especifica√ß√£o DPR.
        app_logger.info(f"DPR_ATTESTATION_VALIDATION: Claims de atestado para {device_id} validados (placeholder).")
        return True # Placeholder: sempre True por enquanto

    def verify_attestation(self, attestation_data_json_b64, expected_device_id, request_id="N/A"):
        """
        Verifica o atestado de dispositivo completo.
        Decodifica, valida formato, timestamp, nonce, assinatura e claims.
        """
        if not self.require_attestation:
             app_logger.debug("DPR_ATTESTATION: Verifica√ß√£o de atesta√ß√£o pulada pois REQUIRE_ATTESTATION √© False.")
             return True

        if self.public_key is None:
            app_logger.critical("DPR_ATTESTATION_FATAL: Chave p√∫blica de atesta√ß√£o n√£o carregada. Verifica√ß√£o de atesta√ß√£o falhou.")
            log_audit(logging.CRITICAL, "Verifica√ß√£o de atestado falhou: Chave p√∫blica ausente.", event_type="ATTESTATION_FAILED", reason="PUBLIC_KEY_MISSING", request_id=request_id)
            return False

        if not attestation_data_json_b64:
            app_logger.warning("DPR_ATTESTATION_VALIDATION: Dados de atesta√ß√£o (X-DPR-Attestation) ausentes no cabe√ßalho.")
            log_audit(logging.WARNING, "Atestado rejeitado: Cabe√ßalho X-DPR-Attestation ausente.", event_type="ATTESTATION_FAILED", reason="HEADER_MISSING", request_id=request_id)
            return False

        try:
            # 1. Decodificar Base64 e JSON
            attestation_payload_bytes = base64.b64decode(attestation_data_json_b64)
            attestation_data = json.loads(attestation_payload_bytes.decode('utf-8'))

            # 2. Extrair campos
            device_id = attestation_data.get("device_id")
            timestamp_str = attestation_data.get("timestamp")
            nonce_from_client = attestation_data.get("nonce")
            attestation_claims = attestation_data.get("attestation_claims", {})
            signature_b64 = attestation_data.get("signature")

            if not all([device_id, timestamp_str, nonce_from_client, signature_b64]):
                 app_logger.warning(f"DPR_ATTESTATION_VALIDATION: Dados de atesta√ß√£o incompletos para dispositivo {device_id}.")
                 log_audit(logging.WARNING, "Atestado rejeitado: Dados incompletos.", event_type="ATTESTATION_FAILED", reason="INCOMPLETE_DATA", device_id=device_id, request_id=request_id)
                 return False

            # 3. Validar Device ID (deve corresponder ao do JWT, se aplic√°vel)
            if expected_device_id and device_id != expected_device_id:
                 app_logger.warning(f"DPR_ATTESTATION_VALIDATION: Device ID no atestado ('{device_id}') n√£o coincide com o esperado ('{expected_device_id}').")
                 log_audit(logging.WARNING, "Atestado rejeitado: Device ID mismatch.", event_type="ATTESTATION_FAILED", reason="DEVICE_ID_MISMATCH", device_id=device_id, expected_device_id=expected_device_id, request_id=request_id)
                 return False

            # 4. Validar Timestamp
            if not self._validate_timestamp(timestamp_str):
                 # _validate_timestamp j√° loga o motivo
                 log_audit(logging.WARNING, "Atestado rejeitado: Valida√ß√£o de timestamp falhou.", event_type="ATTESTATION_FAILED", reason="TIMESTAMP_VALIDATION_FAILED", device_id=device_id, request_id=request_id)
                 return False

            # 5. Validar e Consumir Nonce
            if not self._validate_and_consume_nonce(nonce_from_client):
                 # _validate_and_consume_nonce j√° loga o motivo
                 log_audit(logging.WARNING, "Atestado rejeitado: Valida√ß√£o de nonce falhou.", event_type="ATTESTATION_FAILED", reason="NONCE_VALIDATION_FAILED", device_id=device_id, request_id=request_id)
                 return False

            # 6. Preparar payload para verifica√ß√£o de assinatura (payload can√¥nico)
            # O payload assinado DEVE ser exatamente o que o cliente assinou.
            # Recriamos o dicion√°rio na ordem correta e serializamos de forma can√¥nica.
            signed_payload_dict = {
                "device_id": device_id,
                "timestamp": timestamp_str,
                "nonce": nonce_from_client,
                "attestation_claims": attestation_claims # Inclui claims no payload assinado
            }
            canonical_json_payload_bytes = json.dumps(signed_payload_dict, sort_keys=True, separators=(',', ':')).encode('utf-8')
            
            # 7. Verificar Assinatura
            hasher = hashes.Hash(hashes.SHA256())
            hasher.update(canonical_json_payload_bytes)
            hashed_data_to_verify = hasher.finalize()
            
            signature_bytes = base64.b64decode(signature_b64)

            self.public_key.verify(
                signature_bytes,
                hashed_data_to_verify,
                padding.PKCS1v15(), # Ou PSS, dependendo da implementa√ß√£o do cliente
                hashes.SHA256()
            )
            app_logger.info(f"DPR_ATTESTATION_VALIDATION: Assinatura criptogr√°fica do atestado verificada para dispositivo: {device_id}")

            # 8. Verificar Claims de Atestado
            if not self._verify_attestation_claims(attestation_claims, device_id):
                # _verify_attestation_claims j√° loga o motivo
                log_audit(logging.CRITICAL, f"Atestado rejeitado: Claims de atestado inv√°lidos para o dispositivo {device_id}.", event_type="ATTESTATION_FAILED", reason="INVALID_CLAIMS", device_id=device_id, request_id=request_id, claims=attestation_claims)
                return False

            # 9. Verifica√ß√£o Completa Bem-Sucedida
            app_logger.info(f"DPR_ATTESTATION_SUCCESS: Verifica√ß√£o de atesta√ß√£o completa bem-sucedida para dispositivo: {device_id}")
            log_audit(logging.INFO, "Atestado de dispositivo verificado com sucesso.", event_type="ATTESTATION_SUCCESS", device_id=device_id, request_id=request_id)
            return True

        except InvalidSignature:
             app_logger.critical(f"DPR_ATTESTATION_FATAL: ASSINATURA INV√ÅLIDA para atestado de {expected_device_id}.", exc_info=False)
             log_audit(logging.CRITICAL, "Atestado rejeitado: Assinatura inv√°lida.", event_type="ATTESTATION_FAILED", reason="INVALID_SIGNATURE", device_id=expected_device_id, request_id=request_id)
             return False
        except (ValueError, TypeError, json.JSONDecodeError) as e:
             app_logger.critical(f"DPR_ATTESTATION_FATAL: Falha na decodifica√ß√£o/formato dos dados de atesta√ß√£o para {expected_device_id}: {e!s}", exc_info=True)
             log_audit(logging.CRITICAL, "Atestado rejeitado: Erro de formato/decodifica√ß√£o.", event_type="ATTESTATION_FAILED", reason="DECODING_OR_FORMAT_ERROR", device_id=expected_device_id, request_id=request_id, error=str(e))
             return False
        except Exception as e:
             app_logger.critical(f"DPR_ATTESTATION_FATAL: Erro inesperado durante verifica√ß√£o de atesta√ß√£o para {expected_device_id}: {e!s}", exc_info=True)
             log_audit(logging.CRITICAL, "Atestado rejeitado: Erro inesperado.", event_type="ATTESTATION_FAILED", reason="UNEXPECTED_ERROR", device_id=expected_device_id, request_id=request_id, error=str(e))
             return False


# ==========¬©====DON=====¬Æ==========
# FIM DO ARQUIVO app/lib/device_attestation.py
# SELADO SOB AUTORIDADE DPR.
```
```python
# -*- coding: utf-8 -*-
#
# üúÇ REGENERA A.I.¬Æ BACKEND - EDI√á√ÉO SOBERANA IMPERIAL DEFINITIVA V10.10 üúÇ
# üúÑ ARQUIVO: app/lib/license_client.py üúÑ
#
# M√≥dulo Cliente para Servi√ßo de Licenciamento.
# Desenvolvido por Paulo Ricardo de Le√£o.
#
# Este m√≥dulo √© respons√°vel por comunicar-se com o Servi√ßo de Licenciamento Propriet√°rio
# para verificar o status da licen√ßa desta inst√¢ncia do backend.
#
# Utiliza a chave privada do cliente (DPR_CLIENT_PRIVATE_KEY_PEM) para assinar as requisi√ß√µes
# e a chave p√∫blica do servi√ßo de licen√ßa (DPR_LICENSE_SERVICE_PUBLIC_KEY) para verificar
# a assinatura das respostas, garantindo autenticidade e integridade.
#
# A licen√ßa ativa √© OBRIGAT√ìRIA para a opera√ß√£o dos endpoints de IA. O status da licen√ßa
# √© cacheado e revalidado periodicamente usando Redis para cache distribu√≠do.
#
# ==========¬©====DON=====¬Æ==========

import logging
import requests
import json
import base64
import datetime
from datetime import timezone
import time # Para cache timestamp
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.exceptions import InvalidSignature
# Importar Redis se REDIS_URL estiver configurado
try:
    import redis
    REDIS_AVAILABLE = True
except ImportError:
    REDIS_AVAILABLE = False
    # app_logger.warning("DPR_LICENSE: Redis n√£o dispon√≠vel. Status de licen√ßa ser√° cacheado apenas em mem√≥ria (n√£o escal√°vel para m√∫ltiplos workers).")

from app.utils.logging_config import log_audit # Importa o logger de auditoria

app_logger = logging.getLogger("DPR_LICENSE_CLIENT")

# --- CACHE DE STATUS DE LICEN√áA (Mem√≥ria ou Redis) ---
# Para m√∫ltiplos Gunicorn workers, _LICENSE_CACHE DEVE ser um cache distribu√≠do (Redis).
# Para um √∫nico worker, um dicion√°rio em mem√≥ria √© suficiente.
# A inicializa√ß√£o do Redis deve ser feita uma vez no startup da aplica√ß√£o.
_LICENSE_CACHE = {
    "status": False, # False = Inativa, True = Ativa
    "expires_at": None,
    "last_verification_time": 0 # Timestamp da √∫ltima verifica√ß√£o
}
_REDIS_CLIENT = None # Cliente Redis compartilhado

# Intervalo de revalida√ß√£o da licen√ßa (em segundos)
_VERIFICATION_INTERVAL_SECONDS = 3600 # Padr√£o: 1 hora

def initialize_license_cache(redis_url=None):
    """Inicializa o cliente Redis para cache de status de licen√ßa se REDIS_URL estiver configurado."""
    global _REDIS_CLIENT
    if REDIS_AVAILABLE and redis_url:
        try:
            _REDIS_CLIENT = redis.from_url(redis_url, decode_responses=True)
            # Testar a conex√£o
            _REDIS_CLIENT.ping()
            app_logger.info("DPR_LICENSE_CACHE: Cliente Redis inicializado com sucesso para cache de licen√ßa.")
            # Carregar estado inicial do Redis se existir
            cached_status = _REDIS_CLIENT.get("license_status")
            cached_expires = _REDIS_CLIENT.get("license_expires_at")
            cached_last_check = _REDIS_CLIENT.get("license_last_verification_time")
            
            if cached_status is not None:
                 _LICENSE_CACHE["status"] = cached_status.lower() == 'true'
                 _LICENSE_CACHE["expires_at"] = cached_expires
                 _LICENSE_CACHE["last_verification_time"] = float(cached_last_check) if cached_last_check else 0
                 app_logger.info(f"DPR_LICENSE_CACHE: Estado inicial da licen√ßa carregado do Redis: Status={_LICENSE_CACHE['status']}, Expira={_LICENSE_CACHE['expires_at']}, √öltima Verifica√ß√£o={_LICENSE_CACHE['last_verification_time']:.0f}")

        except redis.exceptions.ConnectionError as e:
            app_logger.error(f"DPR_LICENSE_CACHE_ERROR: Falha ao conectar ao Redis em {redis_url}: {e!s}. Usando cache em mem√≥ria.", exc_info=True)
            _REDIS_CLIENT = None
    elif REDIS_AVAILABLE and not redis_url:
         app_logger.warning("DPR_LICENSE_CACHE: REDIS_URL n√£o configurada. Usando cache de status de licen√ßa em mem√≥ria (n√£o escal√°vel para m√∫ltiplos workers).")
    else:
         app_logger.warning("DPR_LICENSE_CACHE: Biblioteca Redis n√£o instalada. Usando cache de status de licen√ßa em mem√≥ria (n√£o escal√°vel para m√∫ltiplos workers).")


def _update_license_cache(status, expires_at):
    """Atualiza o cache de status de licen√ßa (Mem√≥ria ou Redis)."""
    current_time = datetime.datetime.now(timezone.utc).timestamp()
    _LICENSE_CACHE["status"] = status
    _LICENSE_CACHE["expires_at"] = expires_at
    _LICENSE_CACHE["last_verification_time"] = current_time

    if _REDIS_CLIENT:
        try:
            # Armazenar no Redis com TTL igual ao intervalo de verifica√ß√£o + uma margem?
            # Ou apenas armazenar e confiar na revalida√ß√£o peri√≥dica?
            # Armazenar sem TTL expl√≠cito, a revalida√ß√£o gerencia a atualiza√ß√£o.
            pipe = _REDIS_CLIENT.pipeline()
            pipe.set("license_status", str(status))
            pipe.set("license_expires_at", expires_at if expires_at else "")
            pipe.set("license_last_verification_time", current_time)
            pipe.execute()
            app_logger.debug(f"DPR_LICENSE_CACHE: Cache de licen√ßa atualizado no Redis: Status={status}, Expira={expires_at}.")
        except Exception as e:
            app_logger.error(f"DPR_LICENSE_CACHE_ERROR: Falha ao atualizar cache de licen√ßa no Redis: {e!s}", exc_info=True)


class LicenseClient:
    """
    Cliente para interagir com o Servi√ßo de Licenciamento Propriet√°rio.
    """
    _initialized = False
    _client_private_key = None
    _license_service_public_key = None
    _license_service_url = None
    _config_ref = None

    def __init__(self, config):
        """
        Inicializa o cliente de licen√ßa com chaves e URL do servi√ßo.
        """
        if not LicenseClient._initialized:
            LicenseClient._config_ref = config
            LicenseClient._license_service_url = config.get("DPR_LICENSE_SERVICE_URL")
            
            if not LicenseClient._license_service_url:
                app_logger.critical("DPR_LICENSE_FATAL: DPR_LICENSE_SERVICE_URL n√£o configurado.")
                # A falha na configura√ß√£o cr√≠tica j√° foi logada em config.py
                LicenseClient._initialized = True # Marcar como inicializado, mas inoperante
                return

            client_pk_pem = config.get("DPR_CLIENT_PRIVATE_KEY_PEM")
            if not client_pk_pem:
                app_logger.critical("DPR_LICENSE_FATAL: DPR_CLIENT_PRIVATE_KEY_PEM n√£o configurada ou √© placeholder.")
                LicenseClient._client_private_key = None
            else:
                try:
                    LicenseClient._client_private_key = serialization.load_pem_private_key(
                        client_pk_pem.encode(), password=None
                    )
                    app_logger.info("DPR_LICENSE: Chave privada do cliente carregada para o servi√ßo de licen√ßa.")
                except Exception as e:
                    app_logger.critical(f"DPR_LICENSE_FATAL: Falha ao carregar DPR_CLIENT_PRIVATE_KEY_PEM: {e!s}", exc_info=True)
                    LicenseClient._client_private_key = None
            
            service_pubk_pem = config.get("DPR_LICENSE_SERVICE_PUBLIC_KEY")
            if not service_pubk_pem:
                app_logger.critical("DPR_LICENSE_FATAL: DPR_LICENSE_SERVICE_PUBLIC_KEY n√£o configurada ou √© placeholder.")
                LicenseClient._license_service_public_key = None
            else:
                try:
                    LicenseClient._license_service_public_key = serialization.load_pem_public_key(
                        service_pubk_pem.encode()
                    )
                    app_logger.info("DPR_LICENSE: Chave p√∫blica do servi√ßo de licenciamento carregada.")
                except Exception as e:
                    app_logger.critical(f"DPR_LICENSE_FATAL: Falha ao carregar DPR_LICENSE_SERVICE_PUBLIC_KEY: {e!s}", exc_info=True)
                    LicenseClient._license_service_public_key = None
            
            # Inicializa o cache de licen√ßa se ainda n√£o foi feito
            if _REDIS_CLIENT is None and REDIS_AVAILABLE:
                 initialize_license_cache(config.get("REDIS_URL"))

            # Define o intervalo de verifica√ß√£o a partir da config, se dispon√≠vel
            global _VERIFICATION_INTERVAL_SECONDS
            _VERIFICATION_INTERVAL_SECONDS = config.get("DPR_LICENSE_VERIFICATION_INTERVAL_SECONDS", 3600)

            LicenseClient._initialized = True

    def _sign_payload(self, payload_dict):
        """Assina um payload de dados usando a chave privada do cliente."""
        if not LicenseClient._client_private_key:
            app_logger.error("DPR_LICENSE_SIGN: Chave privada do cliente n√£o dispon√≠vel para assinar payload de licen√ßa.")
            return None
        try:
            # Serializa o payload de forma can√¥nica antes de assinar
            canonical_json_payload = json.dumps(payload_dict, sort_keys=True, separators=(',', ':')).encode('utf-8')
            signature = LicenseClient._client_private_key.sign(
                canonical_json_payload,
                padding.PKCS1v15(), # Ou PSS, dependendo do protocolo com o servi√ßo de licen√ßa
                hashes.SHA256()
            )
            return base64.b64encode(signature).decode('utf-8')
        except Exception as e:
            app_logger.error(f"DPR_LICENSE_SIGN_ERROR: Erro ao assinar payload para servi√ßo de licen√ßa: {e!s}", exc_info=True)
            return None

    def _verify_service_response_signature(self, response_data_dict, signature_b64):
        """Verifica a assinatura da resposta do servi√ßo de licen√ßa usando a chave p√∫blica do servi√ßo."""
        if not LicenseClient._license_service_public_key:
            app_logger.error("DPR_LICENSE_VERIFY: Chave p√∫blica do servi√ßo de licen√ßa n√£o dispon√≠vel para verificar resposta.")
            return False
        try:
            # Serializa os dados da resposta de forma can√¥nica antes de verificar
            canonical_json_response = json.dumps(response_data_dict, sort_keys=True, separators=(',', ':')).encode('utf-8')
            signature = base64.b64decode(signature_b64)
            LicenseClient._license_service_public_key.verify(
                signature,
                canonical_json_response,
                padding.PKCS1v15(), # Deve corresponder ao padding usado pelo servi√ßo
                hashes.SHA256()
            )
            return True
        except InvalidSignature:
            app_logger.critical("DPR_LICENSE_VERIFY_FATAL: Assinatura da resposta do servi√ßo de licen√ßa INV√ÅLIDA.")
            log_audit(logging.CRITICAL, "Verifica√ß√£o de licen√ßa falhou: Assinatura da resposta inv√°lida.", event_type="LICENSE_VERIFICATION_FAILED", reason="INVALID_RESPONSE_SIGNATURE")
            return False
        except Exception as e:
            app_logger.error(f"DPR_LICENSE_VERIFY_ERROR: Erro ao verificar assinatura da resposta do servi√ßo de licen√ßa: {e!s}", exc_info=True)
            return False

    def verify_active_license(self, force_revalidation=False):
        """
        Verifica o status da licen√ßa com o servi√ßo remoto.
        Usa cache a menos que force_revalidation seja True ou o cache tenha expirado.
        """
        current_time = datetime.datetime.now(timezone.utc).timestamp()

        # 1. Checar cache (se n√£o for for√ßado a revalidar e o cache n√£o expirou)
        if not force_revalidation and \
           (current_time - _LICENSE_CACHE["last_verification_time"] < _VERIFICATION_INTERVAL_SECONDS):
            app_logger.debug(f"DPR_LICENSE: Usando status de licen√ßa cacheado ({'ATIVA' if _LICENSE_CACHE['status'] else 'INATIVA'}). Pr√≥xima revalida√ß√£o em ~{_LICENSE_CACHE['last_verification_time'] + _VERIFICATION_INTERVAL_SECONDS - current_time:.0f}s.")
            return _LICENSE_CACHE["status"]

        # 2. Verificar se o cliente est√° inicializado e configurado corretamente
        if not LicenseClient._initialized or not LicenseClient._client_private_key or \
           not LicenseClient._license_service_public_key or not LicenseClient._license_service_url:
            app_logger.critical("DPR_LICENSE_FATAL: Cliente de licen√ßa n√£o inicializado corretamente ou URL/Chaves inv√°lidas. Verifica√ß√£o de licen√ßa abortada.")
            _update_license_cache(False, None) # Garantir que o cache reflita o estado inoperante
            log_audit(logging.CRITICAL, "Verifica√ß√£o de licen√ßa falhou: Cliente n√£o inicializado/configurado.", event_type="LICENSE_VERIFICATION_FAILED", reason="CLIENT_NOT_INITIALIZED")
            return False

        app_logger.info(f"DPR_LICENSE: Revalidando status da licen√ßa em {LicenseClient._license_service_url}...")
        
        # 3. Preparar payload da requisi√ß√£o
        request_payload_data = {
            "device_id": LicenseClient._config_ref.get("DPR_SYSTEM_PROPS", {}).get("nie_rg", "ID_DISPOSITIVO_NAO_DISPONIVEL"),
            "code_uid": LicenseClient._config_ref.get("DPR_SYSTEM_PROPS", {}).get("code_uid"),
            "version": LicenseClient._config_ref.get("DPR_SYSTEM_PROPS", {}).get("version"),
            "timestamp_utc": datetime.datetime.now(timezone.utc).isoformat(),
            # Adicionar outros claims relevantes para o servi√ßo de licen√ßa (ex: IP, hostname, etc.)
            "client_ip": "N/A", # TODO: Capturar IP real da requisi√ß√£o se aplic√°vel
            "client_hostname": "N/A" # TODO: Capturar hostname real
        }
        
        # 4. Assinar o payload
        client_signature = self._sign_payload(request_payload_data)
        if not client_signature:
            app_logger.error("DPR_LICENSE_ERROR: N√£o foi poss√≠vel assinar a requisi√ß√£o de licen√ßa.")
            _update_license_cache(False, None)
            log_audit(logging.ERROR, "Verifica√ß√£o de licen√ßa falhou: Falha na assinatura da requisi√ß√£o.", event_type="LICENSE_VERIFICATION_FAILED", reason="REQUEST_SIGNING_FAILED")
            return False

        final_request_to_service = {
            "data": request_payload_data,
            "signature": client_signature
        }

        # 5. Enviar requisi√ß√£o HTTP para o servi√ßo de licen√ßa
        try:
            http_response = requests.post(
                LicenseClient._license_service_url,
                json=final_request_to_service,
                timeout=20, # Timeout razo√°vel para servi√ßo externo
                headers={"Content-Type": "application/json", "User-Agent": f"DPRRegeneraClient/{LicenseClient._config_ref.get('DPR_SYSTEM_PROPS', {}).get('version')}"},
                verify=True # OBRIGAT√ìRIO: Verificar certificado SSL do servi√ßo de licen√ßa
            )
            http_response.raise_for_status() # Levanta exce√ß√£o para status de erro HTTP (4xx, 5xx)

            # 6. Processar resposta
            service_response_json = http_response.json()
            
            service_response_data = service_response_json.get("data")
            service_signature_b64 = service_response_json.get("signature")

            if not isinstance(service_response_data, dict) or not isinstance(service_signature_b64, str):
                app_logger.error("DPR_LICENSE_ERROR: Resposta do servi√ßo de licen√ßa malformada.")
                _update_license_cache(False, None)
                log_audit(logging.ERROR, "Verifica√ß√£o de licen√ßa falhou: Resposta malformada.", event_type="LICENSE_VERIFICATION_FAILED", reason="MALFORMED_RESPONSE")
                return False

            # 7. Verificar assinatura da resposta
            if not self._verify_service_response_signature(service_response_data, service_signature_b64):
                app_logger.critical("DPR_LICENSE_FATAL: FALHA na verifica√ß√£o da assinatura da resposta do servi√ßo de licen√ßa! Resposta n√£o aut√™ntica.")
                _update_license_cache(False, None)
                # _verify_service_response_signature j√° loga o motivo de auditoria
                return False
            
            app_logger.info("DPR_LICENSE: Assinatura da resposta do servi√ßo de licen√ßa verificada.")
            
            # 8. Validar status da licen√ßa na resposta
            license_status = service_response_data.get("status")
            expires_at = service_response_data.get("expires_at", "N/A")
            reason = service_response_data.get("reason", "N√£o especificado")

            if license_status == "ACTIVE":
                _update_license_cache(True, expires_at)
                app_logger.info(f"DPR_LICENSE_SUCCESS: Licen√ßa ATIVA. Expira em: {expires_at}")
                log_audit(logging.INFO, "Licen√ßa verificada: ATIVA.", event_type="LICENSE_ACTIVE", expires_at=expires_at)
                return True
            else:
                _update_license_cache(False, expires_at)
                app_logger.warning(f"DPR_LICENSE_WARN: Licen√ßa INATIVA ou status '{license_status}'. Raz√£o: {reason}")
                log_audit(logging.WARNING, "Licen√ßa verificada: INATIVA.", event_type="LICENSE_INACTIVE", status=license_status, reason=reason, expires_at=expires_at)
                return False

        except requests.exceptions.Timeout:
            app_logger.critical(f"DPR_LICENSE_FATAL: Timeout na comunica√ß√£o com o servi√ßo de licenciamento: {LicenseClient._license_service_url}")
            _update_license_cache(False, None)
            log_audit(logging.CRITICAL, "Verifica√ß√£o de licen√ßa falhou: Timeout.", event_type="LICENSE_VERIFICATION_FAILED", reason="TIMEOUT", service_url=LicenseClient._license_service_url)
            return False
        except requests.exceptions.SSLError as e:
            app_logger.critical(f"DPR_LICENSE_FATAL: Erro SSL na comunica√ß√£o com o servi√ßo de licenciamento: {e!s}. Verifique o certificado do servidor.")
            _update_license_cache(False, None)
            log_audit(logging.CRITICAL, "Verifica√ß√£o de licen√ßa falhou: Erro SSL.", event_type="LICENSE_VERIFICATION_FAILED", reason="SSL_ERROR", service_url=LicenseClient._license_service_url, error=str(e))
            return False
        except requests.exceptions.RequestException as e:
            app_logger.critical(f"DPR_LICENSE_FATAL: Falha na comunica√ß√£o HTTP com o servi√ßo de licenciamento: {e!s}")
            _update_license_cache(False, None)
            log_audit(logging.CRITICAL, "Verifica√ß√£o de licen√ßa falhou: Erro HTTP.", event_type="LICENSE_VERIFICATION_FAILED", reason="HTTP_ERROR", service_url=LicenseClient._license_service_url, error=str(e))
            return False
        except (json.JSONDecodeError, Exception) as e:
             app_logger.critical(f"DPR_LICENSE_FATAL: Erro no processamento da resposta do servi√ßo de licenciamento: {e!s}", exc_info=True)
             _update_license_cache(False, None)
             log_audit(logging.CRITICAL, "Verifica√ß√£o de licen√ßa falhou: Erro no processamento da resposta.", event_type="LICENSE_VERIFICATION_FAILED", reason="RESPONSE_PROCESSING_ERROR", error=str(e))
             return False

    def is_license_active(self):
        """
        Retorna o status atual da licen√ßa, revalidando se o cache expirou.
        Esta √© a fun√ß√£o principal a ser chamada pelos endpoints protegidos.
        """
        current_time = datetime.datetime.now(timezone.utc).timestamp()
        
        # Se o cache expirou, tenta revalidar
        if (current_time - _LICENSE_CACHE["last_verification_time"] >= _VERIFICATION_INTERVAL_SECONDS):
            app_logger.info("DPR_LICENSE: Intervalo de verifica√ß√£o da licen√ßa expirado. Revalidando...")
            self.verify_active_license(force_revalidation=True)
        
        # Retorna o status do cache (atualizado ou n√£o)
        return _LICENSE_CACHE["status"]

    @classmethod
    def get_license_status_details(cls):
        """Retorna os detalhes completos do status da licen√ßa cacheada."""
        return _LICENSE_CACHE.copy()

# ==========¬©====DON=====¬Æ==========
# FIM DO ARQUIVO app/lib/license_client.py
# SELADO SOB AUTORIDADE DPR.
```
```python
# -*- coding: utf-8 -*-
#
# üúÇ REGENERA A.I.¬Æ BACKEND - EDI√á√ÉO SOBERANA IMPERIAL DEFINITIVA V10.10 üúÇ
# üúÑ ARQUIVO: app/core/security.py üúÑ
#
# M√≥dulo de Configura√ß√£o de Seguran√ßa (JWT, Atestado, Licen√ßa, 2FA, Blacklist).
# Desenvolvido por Paulo Ricardo de Le√£o.
#
# Este m√≥dulo configura o Flask-JWT-Extended e define os decoradores de seguran√ßa
# para proteger os endpoints da API.
#
# Inclui decoradores para:
# - Exigir um Token JWT v√°lido (`@dpr_jwt_required`).
# - Exigir um Atestado de Dispositivo v√°lido no cabe√ßalho (`@require_device_attestation`).
# - Exigir uma Licen√ßa Ativa do Sistema (`@require_active_license`).
# - Exigir permiss√µes espec√≠ficas baseadas em claims JWT (`@dpr_permission_required`).
#
# Implementa JWT Blacklist usando Redis e l√≥gica de 2FA/TOTP.
#
# ==========¬©====DON=====¬Æ==========

import logging
from flask import jsonify, request, current_app, g
from flask_jwt_extended import JWTManager, verify_jwt_in_request, get_jwt_identity, get_jwt, create_access_token, get_jti
from functools import wraps
from app.lib.device_attestation import DeviceAttestation
from app.lib.license_client import LicenseClient
from app.utils.logging_config import log_audit # Importa o logger de auditoria
import datetime
from datetime import timezone
import pyotp # Para TOTP
import base64 # Para QR Code
import io # Para QR Code
import qrcode # Para QR Code
try:
    import redis
    REDIS_AVAILABLE = True
except ImportError:
    REDIS_AVAILABLE = False

app_logger = logging.getLogger("DPR_SECURITY")

# Inst√¢ncia do JWTManager (inicializada em app.py)
jwt_manager = JWTManager()

# Inst√¢ncias globais para os clientes de seguran√ßa (inicializadas em app.py)
_device_attestation_verifier = None
_license_client = None
_redis_client = None # Cliente Redis para JWT Blacklist e 2FA secrets

# --- JWT Blacklist (Usando Redis) ---
# A blacklist armazena JTIs de tokens revogados.
# Requer um cliente Redis inicializado.

def _is_token_revoked(jwt_payload):
    """Verifica se o token JWT est√° na blacklist."""
    jti = jwt_payload.get("jti")
    if not jti:
        return False # Token sem JTI n√£o pode ser revogado (configura√ß√£o JWT inv√°lida)
    
    if _redis_client:
        try:
            # Verifica se o JTI existe no Redis (como chave ou em um set)
            # Usamos um set para armazenar JTIs revogados
            is_revoked = _redis_client.sismember("jwt_blacklist", jti)
            if is_revoked:
                 app_logger.debug(f"DPR_SECURITY: Token JTI '{jti[:8]}...' encontrado na blacklist.")
            return is_revoked
        except Exception as e:
            app_logger.error(f"DPR_SECURITY_ERROR: Falha ao verificar blacklist JWT no Redis: {e!s}. Assumindo token N√ÉO revogado por seguran√ßa.", exc_info=True)
            # Em caso de erro no Redis, a pol√≠tica de seguran√ßa pode variar.
            # Assumir N√ÉO revogado evita DoS se o Redis cair, mas permite uso de tokens revogados.
            # Uma pol√≠tica mais segura seria assumir revogado em caso de erro.
            return False # Pol√≠tica padr√£o: permitir se n√£o puder verificar
    else:
        # Sem Redis, blacklist em mem√≥ria (n√£o escal√°vel) ou desabilitada
        # Para um sistema Enterprise real, Redis √© OBRIGAT√ìRIO para blacklist.
        app_logger.warning("DPR_SECURITY_WARN: Redis n√£o configurado. JWT Blacklist inoperante.")
        return False # Blacklist inoperante

def _add_token_to_blacklist(jti, expires_timestamp):
    """Adiciona um JTI √† blacklist com tempo de expira√ß√£o."""
    if _redis_client:
        try:
            # Adiciona o JTI a um set de blacklist e define um TTL para o set (opcional, mas boa pr√°tica)
            # Ou armazena cada JTI como uma chave com seu pr√≥prio TTL
            # Armazenar cada JTI como chave com TTL = tempo restante do token √© mais preciso.
            now = datetime.datetime.now(timezone.utc).timestamp()
            ttl_seconds = max(0, int(expires_timestamp - now)) # TTL √© o tempo restante de vida do token
            if ttl_seconds > 0:
                 _redis_client.set(f"revoked_token:{jti}", "true", ex=ttl_seconds)
                 app_logger.debug(f"DPR_SECURITY: Token JTI '{jti[:8]}...' adicionado √† blacklist Redis com TTL de {ttl_seconds}s.")
            else:
                 app_logger.warning(f"DPR_SECURITY_WARN: Tentativa de adicionar token expirado √† blacklist: JTI '{jti[:8]}...'.")

        except Exception as e:
            app_logger.error(f"DPR_SECURITY_ERROR: Falha ao adicionar JTI '{jti[:8]}...' √† blacklist Redis: {e!s}", exc_info=True)
    else:
        app_logger.warning("DPR_SECURITY_WARN: Redis n√£o configurado. N√£o √© poss√≠vel adicionar JTI √† blacklist.")

# Configurar o callback para verificar a blacklist em cada requisi√ß√£o
@jwt_manager.token_in_blocklist_loader
def check_if_token_in_blacklist(jwt_header, jwt_payload):
    """Callback para Flask-JWT-Extended verificar a blacklist."""
    return _is_token_revoked(jwt_payload)


# --- 2FA/TOTP (Para Login Administrativo) ---
# Requer pyotp e qrcode
# O segredo 2FA DEVE ser gerido como um segredo CR√çTICO (DPR_ADMIN_2FA_SECRET).

def _get_admin_2fa_secret():
    """Obt√©m o segredo 2FA do administrador da configura√ß√£o."""
    return current_app.config.get("DPR_ADMIN_2FA_SECRET")

def _is_2fa_required():
    """Verifica se 2FA √© obrigat√≥rio para login administrativo."""
    return current_app.config.get("REQUIRE_ADMIN_2FA", False)

def _verify_totp_code(secret, code):
    """Verifica um c√≥digo TOTP contra um segredo."""
    if not secret or not code:
        return False
    try:
        totp = pyotp.TOTP(secret)
        return totp.verify(code)
    except Exception as e:
        app_logger.error(f"DPR_SECURITY_ERROR: Erro ao verificar c√≥digo TOTP: {e!s}", exc_info=True)
        return False

def _generate_totp_uri(secret, account_name, issuer_name):
    """Gera a URI para configurar o TOTP no aplicativo autenticador."""
    if not secret or not account_name or not issuer_name:
        return None
    try:
        totp = pyotp.TOTP(secret)
        return totp.provisioning_uri(account_name, issuer_name=issuer_name)
    except Exception as e:
        app_logger.error(f"DPR_SECURITY_ERROR: Erro ao gerar URI TOTP: {e!s}", exc_info=True)
        return None

def _generate_qrcode_png(uri):
    """Gera um QR Code PNG a partir de uma URI."""
    if not uri:
        return None
    try:
        img = qrcode.make(uri)
        buffer = io.BytesIO()
        img.save(buffer, format="PNG")
        return buffer.getvalue()
    except Exception as e:
        app_logger.error(f"DPR_SECURITY_ERROR: Erro ao gerar QR Code: {e!s}", exc_info=True)
        return None


# --- Inicializa√ß√£o de Componentes de Seguran√ßa ---

def initialize_security(app):
    """
    Inicializa o Flask-JWT-Extended e as inst√¢ncias dos clientes de seguran√ßa.
    Chamado pela f√°brica da aplica√ß√£o (app.py).
    """
    global _device_attestation_verifier, _license_client, _redis_client

    # Configura√ß√µes JWT
    app.config["JWT_SECRET_KEY"] = app.config.get("DPR_JWT_SECRET_KEY")
    app.config["JWT_ALGORITHM"] = app.config.get("DPR_JWT_ALGORITHM", "HS512")
    app.config["JWT_ACCESS_TOKEN_EXPIRES"] = datetime.timedelta(seconds=app.config.get("DPR_JWT_EXP_DELTA_SECONDS", 14400))
    app.config["JWT_REFRESH_TOKEN_EXPIRES"] = datetime.timedelta(days=30) # Exemplo, ajustar conforme pol√≠tica DPR
    app.config["JWT_TOKEN_LOCATION"] = ["headers"] # Apenas cabe√ßalhos (Bearer)
    app.config["JWT_HEADER_NAME"] = "Authorization"
    app.config["JWT_HEADER_TYPE"] = "Bearer"
    app.config["JWT_IDENTITY_CLAIM"] = "sub" # Assunto do token (geralmente user_id)
    app.config["JWT_USER_CLAIMS"] = "dpr_claims" # Nome do campo para claims customizados (device_id, permissions)
    app.config["JWT_BLACKLIST_ENABLED"] = True # Habilitar blacklist
    app.config["JWT_BLACKLIST_TOKEN_CHECKS"] = ["access", "refresh"] # Aplicar blacklist a access e refresh tokens

    jwt_manager.init_app(app)
    app_logger.info("DPR_SECURITY: Flask-JWT-Extended inicializado.")

    # Inicializa cliente Redis para JWT Blacklist e caches de seguran√ßa
    redis_url = app.config.get("REDIS_URL")
    if REDIS_AVAILABLE and redis_url:
        try:
            _redis_client = redis.from_url(redis_url, decode_responses=True)
            _redis_client.ping() # Testar conex√£o
            app_logger.info("DPR_SECURITY: Cliente Redis inicializado para JWT Blacklist e caches de seguran√ßa.")
        except redis.exceptions.ConnectionError as e:
            app_logger.critical(f"DPR_SECURITY_FATAL: Falha ao conectar ao Redis em {redis_url}: {e!s}. JWT Blacklist e caches de seguran√ßa inoperantes.", exc_info=True)
            _redis_client = None # Garantir que seja None em caso de falha
    elif REDIS_AVAILABLE and not redis_url:
         app_logger.warning("DPR_SECURITY_WARN: REDIS_URL n√£o configurada. JWT Blacklist e caches de seguran√ßa inoperantes.")
    else:
         app_logger.warning("DPR_SECURITY_WARN: Biblioteca Redis n√£o instalada. JWT Blacklist e caches de seguran√ßa inoperantes.")


    # Inicializa clientes de seguran√ßa com a configura√ß√£o da aplica√ß√£o
    try:
        _device_attestation_verifier = DeviceAttestation(app.config)
        app_logger.info("DPR_SECURITY: Verificador de Atestado de Dispositivo inicializado.")
    except ValueError as e:
        app_logger.fatal(f"DPR_SECURITY_FATAL: Falha na inicializa√ß√£o do Verificador de Atestado: {e!s}. Atesta√ß√£o ser√° inoperante.", exc_info=True)
        _device_attestation_verifier = None # Garantir que seja None em caso de falha

    try:
        _license_client = LicenseClient(app.config)
        app_logger.info("DPR_SECURITY: Cliente de Licen√ßa inicializado.")
    except ValueError as e:
        app_logger.fatal(f"DPR_SECURITY_FATAL: Falha na inicializa√ß√£o do Cliente de Licen√ßa: {e!s}. Verifica√ß√£o de licen√ßa ser√° inoperante.", exc_info=True)
        _license_client = None # Garantir que seja None em caso de falha


    # --- Handlers de Erro JWT Customizados ---
    # Estes handlers retornam respostas padronizadas DPR¬Æ em caso de falhas JWT.

    @jwt_manager.unauthorized_loader
    def custom_unauthorized_callback(callback):
        # Capturar request_id do objeto g, se dispon√≠vel (definido no before_request)
        request_id = getattr(g, 'request_id', 'N/A')
        log_audit(logging.WARNING, "Acesso n√£o autorizado: Token JWT ausente ou inv√°lido.", event_type="AUTH_FAILED", reason="JWT_MISSING_OR_INVALID", path=request.path, method=request.method, ip_address=request.remote_addr, request_id=request_id)
        return jsonify({
            "status": "error",
            "message": "DPR_AUTH_ERROR: Credenciais de autentica√ß√£o ausentes ou inv√°lidas. Requer Token JWT v√°lido.",
            "code": "DPR_401_UNAUTHORIZED"
        }), 401

    @jwt_manager.invalid_token_loader
    def custom_invalid_token_callback(callback):
        request_id = getattr(g, 'request_id', 'N/A')
        log_audit(logging.WARNING, "Acesso n√£o autorizado: Token JWT inv√°lido.", event_type="AUTH_FAILED", reason="JWT_INVALID", path=request.path, method=request.method, ip_address=request.remote_addr, request_id=request_id)
        return jsonify({
            "status": "error",
            "message": "DPR_AUTH_ERROR: Token JWT inv√°lido. Verifique o formato e a assinatura.",
            "code": "DPR_422_INVALID_TOKEN"
        }), 422

    @jwt_manager.expired_token_loader
    def custom_expired_token_callback(jwt_header, jwt_payload):
        request_id = getattr(g, 'request_id', 'N/A')
        identity = jwt_payload.get('sub', 'N/A')
        log_audit(logging.WARNING, f"Acesso n√£o autorizado: Token JWT expirado para identidade '{identity}'.", event_type="AUTH_FAILED", reason="JWT_EXPIRED", identity=identity, path=request.path, method=request.method, ip_address=request.remote_addr, request_id=request_id)
        return jsonify({
            "status": "error",
            "message": "DPR_AUTH_ERROR: Token JWT expirado. Obtenha um novo token.",
            "code": "DPR_401_EXPIRED_TOKEN"
        }), 401

    @jwt_manager.revoked_token_loader
    def custom_revoked_token_callback(jwt_header, jwt_payload):
        request_id = getattr(g, 'request_id', 'N/A')
        identity = jwt_payload.get('sub', 'N/A')
        log_audit(logging.WARNING, f"Acesso n√£o autorizado: Token JWT revogado para identidade '{identity}'.", event_type="AUTH_FAILED", reason="JWT_REVOKED", identity=identity, path=request.path, method=request.method, ip_address=request.remote_addr, request_id=request_id)
        return jsonify({
            "status": "error",
            "message": "DPR_AUTH_ERROR: Token JWT revogado. Este token n√£o √© mais v√°lido.",
            "code": "DPR_401_REVOKED_TOKEN"
        }), 401

    @jwt_manager.needs_fresh_token_loader
    def custom_needs_fresh_token_callback(jwt_header, jwt_payload):
        request_id = getattr(g, 'request_id', 'N/A')
        identity = jwt_payload.get('sub', 'N/A')
        log_audit(logging.WARNING, f"Acesso n√£o autorizado: Token JWT n√£o √© 'fresh' para identidade '{identity}'.", event_type="AUTH_FAILED", reason="JWT_NOT_FRESH", identity=identity, path=request.path, method=request.method, ip_address=request.remote_addr, request_id=request_id)
        return jsonify({
            "status": "error",
            "message": "DPR_AUTH_ERROR: Requer um Token JWT 'fresh' para esta opera√ß√£o.",
            "code": "DPR_401_FRESH_TOKEN_REQUIRED"
        }), 401

    @jwt_manager.token_verification_error_loader
    def custom_token_verification_error_callback(jwt_header, jwt_payload):
         request_id = getattr(g, 'request_id', 'N/A')
         log_audit(logging.WARNING, "Erro na verifica√ß√£o do Token JWT.", event_type="AUTH_FAILED", reason="JWT_VERIFICATION_ERROR", path=request.path, method=request.method, ip_address=request.remote_addr, request_id=request_id)
         return jsonify({
            "status": "error",
            "message": "DPR_AUTH_ERROR: Erro durante a verifica√ß√£o do Token JWT.",
            "code": "DPR_422_TOKEN_VERIFICATION_ERROR"
        }), 422


# --- DECORADORES DE SEGURAN√áA ---

def dpr_jwt_required(fn):
    """
    Decorador customizado para exigir um Token JWT v√°lido.
    Envolve o decorador padr√£o verify_jwt_in_request.
    Adiciona claims DPR (user_id, device_id, request_id, permissions) ao objeto request.
    """
    @wraps(fn)
    def wrapper(*args, **kwargs):
        try:
            verify_jwt_in_request()
            # O token √© v√°lido, a identidade e claims est√£o dispon√≠veis via get_jwt_identity() e get_jwt()
            user_id = get_jwt_identity()
            claims = get_jwt()
            dpr_claims = claims.get("dpr_claims", {})
            device_id = dpr_claims.get("device_id", "N/A")
            request_id = getattr(g, 'request_id', 'N/A') # Capturar request_id do objeto g

            # Adicionar metadados DPR ao objeto request para f√°cil acesso nos endpoints subsequentes
            request.dpr_user_id = user_id
            request.dpr_device_id = device_id
            request.dpr_request_id = request_id
            request.dpr_claims = dpr_claims

            app_logger.debug(f"DPR_SECURITY: JWT v√°lido para user '{user_id}', device '{device_id}'.")
            return fn(*args, **kwargs)
        except Exception as e:
            # Os handlers de erro JWT customizados j√° lidam com as exce√ß√µes JWT
            # Qualquer outra exce√ß√£o aqui indica um problema inesperado
            app_logger.error(f"DPR_SECURITY_ERROR: Erro inesperado na verifica√ß√£o JWT: {e!s}", exc_info=True)
            request_id = getattr(g, 'request_id', 'N/A')
            log_audit(logging.ERROR, "Erro inesperado na verifica√ß√£o JWT.", event_type="AUTH_ERROR", reason="UNEXPECTED_ERROR", error=str(e), path=request.path, method=request.method, ip_address=request.remote_addr, request_id=request_id)
            return jsonify({
                "status": "error",
                "message": "DPR_AUTH_ERROR: Erro interno durante a autentica√ß√£o.",
                "code": "DPR_500_INTERNAL_AUTH_ERROR"
            }), 500
    return wrapper

def require_device_attestation(fn):
    """
    Decorador para exigir um Atestado de Dispositivo v√°lido no cabe√ßalho X-DPR-Attestation.
    DEVE ser usado AP√ìS @dpr_jwt_required para ter acesso aos claims do token (device_id).
    """
    @wraps(fn)
    def wrapper(*args, **kwargs):
        # Acessar a inst√¢ncia do verificador de atestado armazenada nas extens√µes da aplica√ß√£o
        attestation_verifier = current_app.extensions.get('device_attestation_verifier')
        
        # Acessar metadados DPR do objeto request (definidos por @dpr_jwt_required)
        user_id = getattr(request, 'dpr_user_id', 'N/A')
        device_id = getattr(request, 'dpr_device_id', 'N/A')
        request_id = getattr(request, 'dpr_request_id', 'N/A')

        if attestation_verifier is None:
            app_logger.critical("DPR_SECURITY_FATAL: Verificador de Atestado n√£o inicializado. N√£o √© poss√≠vel aplicar a restri√ß√£o.")
            log_audit(logging.CRITICAL, "Acesso negado: Verificador de Atestado inoperante.", event_type="ACCESS_DENIED", reason="ATTESTATION_VERIFIER_UNAVAILABLE", user_id=user_id, device_id=device_id, request_id=request_id, path=request.path)
            return jsonify({
                "status": "error",
                "message": "DPR_SECURITY_ERROR: Servi√ßo de verifica√ß√£o de atestado de dispositivo inoperante. Contate o suporte.",
                "code": "DPR_500_ATTESTATION_UNAVAILABLE"
            }), 500

        if not attestation_verifier.require_attestation:
             app_logger.debug("DPR_SECURITY: Verifica√ß√£o de atestado desabilitada pela configura√ß√£o. Pulando.")
             return fn(*args, **kwargs)

        attestation_data_b64 = request.headers.get("X-DPR-Attestation")

        if not attestation_data_b64:
            app_logger.warning(f"DPR_SECURITY: Acesso negado para user '{user_id}', device '{device_id}': Cabe√ßalho X-DPR-Attestation ausente.")
            log_audit(logging.WARNING, "Acesso negado: Cabe√ßalho X-DPR-Attestation ausente.", event_type="ACCESS_DENIED", reason="ATTESTATION_HEADER_MISSING", user_id=user_id, device_id=device_id, request_id=request_id, path=request.path)
            return jsonify({
                "status": "error",
                "message": "DPR_SECURITY_ERROR: Requer Atestado de Dispositivo (X-DPR-Attestation header).",
                "code": "DPR_403_ATTESTATION_REQUIRED"
            }), 403

        # Passa o device_id do JWT para o verificador para garantir que o atestado √© para o dispositivo correto
        if attestation_verifier.verify_attestation(attestation_data_b64, expected_device_id=device_id, request_id=request_id):
            app_logger.debug(f"DPR_SECURITY: Atestado de dispositivo verificado com sucesso para user '{user_id}', device '{device_id}'.")
            return fn(*args, **kwargs)
        else:
            app_logger.warning(f"DPR_SECURITY: Acesso negado para user '{user_id}', device '{device_id}': Verifica√ß√£o de atestado falhou.")
            # O motivo espec√≠fico da falha j√° foi logado dentro de verify_attestation
            log_audit(logging.WARNING, "Acesso negado: Verifica√ß√£o de atestado falhou.", event_type="ACCESS_DENIED", reason="ATTESTATION_FAILED", user_id=user_id, device_id=device_id, request_id=request_id, path=request.path)
            return jsonify({
                "status": "error",
                "message": "DPR_SECURITY_ERROR: Verifica√ß√£o de Atestado de Dispositivo falhou. O dispositivo pode n√£o ser confi√°vel ou o atestado √© inv√°lido.",
                "code": "DPR_403_ATTESTATION_FAILED"
            }), 403

    return wrapper

def require_active_license(fn):
    """
    Decorador para exigir que a licen√ßa do sistema REGENERA A.I.¬Æ esteja ativa.
    DEVE ser usado AP√ìS @dpr_jwt_required.
    """
    @wraps(fn)
    def wrapper(*args, **kwargs):
        # Acessar a inst√¢ncia do cliente de licen√ßa armazenada nas extens√µes da aplica√ß√£o
        license_client = current_app.extensions.get('license_client')
        
        # Acessar metadados DPR do objeto request (definidos por @dpr_jwt_required)
        user_id = getattr(request, 'dpr_user_id', 'N/A')
        device_id = getattr(request, 'dpr_device_id', 'N/A')
        request_id = getattr(request, 'dpr_request_id', 'N/A')


        if license_client is None:
            app_logger.critical("DPR_SECURITY_FATAL: Cliente de Licen√ßa n√£o inicializado. N√£o √© poss√≠vel aplicar a restri√ß√£o.")
            log_audit(logging.CRITICAL, "Acesso negado: Cliente de Licen√ßa inoperante.", event_type="ACCESS_DENIED", reason="LICENSE_CLIENT_UNAVAILABLE", user_id=user_id, device_id=device_id, request_id=request_id, path=request.path)
            return jsonify({
                "status": "error",
                "message": "DPR_SECURITY_ERROR: Servi√ßo de verifica√ß√£o de licen√ßa inoperante. Contate o suporte.",
                "code": "DPR_500_LICENSE_UNAVAILABLE"
            }), 500

        if license_client.is_license_active():
            app_logger.debug(f"DPR_SECURITY: Licen√ßa ativa verificada para user '{user_id}', device '{device_id}'.")
            return fn(*args, **kwargs)
        else:
            app_logger.warning(f"DPR_SECURITY: Acesso negado para user '{user_id}', device '{device_id}': Licen√ßa inativa.")
            # O motivo espec√≠fico da inatividade da licen√ßa j√° foi logado dentro de is_license_active/verify_active_license
            log_audit(logging.WARNING, "Acesso negado: Licen√ßa inativa.", event_type="ACCESS_DENIED", reason="LICENSE_INACTIVE", user_id=user_id, device_id=device_id, request_id=request_id, path=request.path)
            return jsonify({
                "status": "error",
                "message": "DPR_SECURITY_ERROR: A licen√ßa do sistema REGENERA A.I.¬Æ n√£o est√° ativa. Funcionalidade de IA restrita. Contate o suporte para ativar sua licen√ßa.",
                "code": "DPR_403_LICENSE_INACTIVE"
            }), 403

    return wrapper

def dpr_permission_required(permission):
    """
    Decorador para exigir uma permiss√£o espec√≠fica nos claims JWT (dpr_claims.permissions).
    DEVE ser usado AP√ìS @dpr_jwt_required.
    """
    def decorator(fn):
        @wraps(fn)
        def wrapper(*args, **kwargs):
            # Acessar metadados DPR do objeto request (definidos por @dpr_jwt_required)
            user_id = getattr(request, 'dpr_user_id', 'N/A')
            device_id = getattr(request, 'dpr_device_id', 'N/A')
            request_id = getattr(request, 'dpr_request_id', 'N/A')
            dpr_claims = getattr(request, 'dpr_claims', {})

            user_permissions = dpr_claims.get("permissions", [])

            if permission in user_permissions:
                app_logger.debug(f"DPR_SECURITY: Permiss√£o '{permission}' concedida para user '{user_id}', device '{device_id}'.")
                return fn(*args, **kwargs)
            else:
                app_logger.warning(f"DPR_SECURITY: Acesso negado para user '{user_id}', device '{device_id}': Permiss√£o '{permission}' requerida, mas n√£o concedida. Permiss√µes do usu√°rio: {user_permissions}")
                log_audit(logging.WARNING, f"Acesso negado: Permiss√£o '{permission}' requerida.", event_type="ACCESS_DENIED", reason="PERMISSION_DENIED", user_id=user_id, device_id=device_id, request_id=request_id, path=request.path, required_permission=permission, user_permissions=user_permissions)
                return jsonify({
                    "status": "error",
                    "message": f"DPR_SECURITY_ERROR: Permiss√£o '{permission}' requerida para acessar este recurso. Sua licen√ßa ou perfil de usu√°rio n√£o a concede.",
                    "code": "DPR_403_PERMISSION_DENIED"
                }), 403
        return wrapper
    return decorator


# --- Fun√ß√µes Auxiliares de JWT ---

def create_dpr_jwt(identity, device_id, permissions, additional_claims=None):
    """
    Cria um Token JWT com claims customizados DPR¬Æ.
    """
    if additional_claims is None:
        additional_claims = {}

    # Inclui claims DPR¬Æ espec√≠ficos
    dpr_claims = {
        "device_id": device_id,
        "permissions": permissions,
        "issued_at_utc": datetime.datetime.now(timezone.utc).isoformat(),
        **additional_claims # Inclui quaisquer claims adicionais
    }

    # Cria o token de acesso com a identidade e claims customizados
    access_token = create_access_token(identity=identity, additional_claims={"dpr_claims": dpr_claims})
    
    app_logger.info(f"DPR_SECURITY: Token JWT criado para user '{identity}', device '{device_id}'. Claims: {dpr_claims}")
    log_audit(logging.INFO, "Token JWT criado.", event_type="JWT_CREATED", user_id=identity, device_id=device_id, permissions=permissions)

    return access_token

def revoke_jwt(token):
    """
    Adiciona um token JWT √† blacklist.
    Args:
        token (str): O token JWT a ser revogado.
    Returns:
        bool: True se adicionado √† blacklist com sucesso, False caso contr√°rio.
    """
    try:
        # Decodificar o token para obter o JTI e a data de expira√ß√£o
        # verify=False porque queremos apenas ler os claims, n√£o validar a assinatura aqui
        # (a valida√ß√£o da assinatura √© feita pelo Flask-JWT-Extended)
        from flask_jwt_extended import decode_token
        decoded_token = decode_token(token, allow_expired=True, allow_blocklisted=True, verify=False)
        jti = decoded_token.get("jti")
        expires_timestamp = decoded_token.get("exp")

        if not jti or not expires_timestamp:
            app_logger.warning("DPR_SECURITY_WARN: Tentativa de revogar token sem JTI ou expira√ß√£o.")
            return False

        _add_token_to_blacklist(jti, expires_timestamp)
        app_logger.info(f"DPR_SECURITY: Token JTI '{jti[:8]}...' revogado e adicionado √† blacklist.")
        log_audit(logging.INFO, "Token JWT revogado.", event_type="JWT_REVOKED", jti=jti[:8]+"...", expires_at=datetime.datetime.fromtimestamp(expires_timestamp, tz=timezone.utc).isoformat())
        return True
    except Exception as e:
        app_logger.error(f"DPR_SECURITY_ERROR: Falha ao revogar token: {e!s}", exc_info=True)
        log_audit(logging.ERROR, "Falha ao revogar token JWT.", event_type="JWT_REVOCATION_FAILED", error=str(e))
        return False

# --- Fun√ß√µes Auxiliares de 2FA ---

def generate_admin_2fa_secret():
    """Gera um novo segredo TOTP para o administrador."""
    # pyotp.random_base32() gera um segredo seguro
    secret = pyotp.random_base32()
    app_logger.info("DPR_SECURITY: Novo segredo 2FA para administrador gerado.")
    # Este segredo DEVE ser armazenado de forma segura (Secrets Manager) e configurado em DPR_ADMIN_2FA_SECRET.
    # N√£o logar o segredo real!
    log_audit(logging.INFO, "Novo segredo 2FA para administrador gerado.", event_type="ADMIN_2FA_SECRET_GENERATED")
    return secret

def get_admin_2fa_qrcode(secret):
    """Gera um QR Code PNG para o segredo 2FA do administrador."""
    if not secret:
        app_logger.error("DPR_SECURITY_ERROR: N√£o √© poss√≠vel gerar QR Code 2FA: Segredo ausente.")
        return None
    # Usar um nome de conta e emissor consistentes
    uri = _generate_totp_uri(secret, "admin@REGENERA.AI", "REGENERA.AI")
    if uri:
        return _generate_qrcode_png(uri)
    return None

def verify_admin_2fa_code(code):
    """Verifica um c√≥digo TOTP fornecido pelo administrador."""
    secret = _get_admin_2fa_secret()
    if not secret:
        app_logger.error("DPR_SECURITY_ERROR: N√£o √© poss√≠vel verificar 2FA: Segredo do administrador n√£o configurado.")
        log_audit(logging.ERROR, "Verifica√ß√£o 2FA falhou: Segredo do administrador ausente.", event_type="ADMIN_2FA_FAILED", reason="SECRET_MISSING")
        return False
    
    is_valid = _verify_totp_code(secret, code)
    if is_valid:
        app_logger.debug("DPR_SECURITY: C√≥digo TOTP 2FA v√°lido.")
    else:
        app_logger.warning("DPR_SECURITY_WARN: C√≥digo TOTP 2FA inv√°lido.")
        log_audit(logging.WARNING, "Verifica√ß√£o 2FA falhou: C√≥digo TOTP inv√°lido.", event_type="ADMIN_2FA_FAILED", reason="INVALID_CODE")
    
    return is_valid

# ==========¬©====DON=====¬Æ==========
# FIM DO ARQUIVO app/core/security.py
# SELADO SOB AUTORIDADE DPR.
```
```python
# -*- coding: utf-8 -*-
#
# üúÇ REGENERA A.I.¬Æ BACKEND - EDI√á√ÉO SOBERANA IMPERIAL DEFINITIVA V10.10 üúÇ
# üúÑ ARQUIVO: app/core/quantum_core.py üúÑ
#
# Core de Processamento Qu√¢ntico.
# Desenvolvido por Paulo Ricardo de Le√£o.
#
# Este m√≥dulo √© respons√°vel por gerenciar a conex√£o e a execu√ß√£o de Circuitos
# Qu√¢nticos Propriet√°rios na IBM Quantum Platform (hardware ou simulador AER).
# Ele atua como middleware entre algoritmos qu√¢nticos definidos e o hardware/simulador,
# mantendo a soberania da l√≥gica algor√≠tmica e dos dados.
#
# ==========¬©====DON=====¬Æ==========

import logging
import os

# --- IMPORTA√á√ïES PARA INTERA√á√ÉO COM IBM QUANTUM VIA QISKIT ---
try:
    from qiskit_ibm_provider import IBMProvider, least_busy # least_busy pode ser √∫til
    from qiskit_aer import AerSimulator # Para simula√ß√£o local
    from qiskit import QuantumCircuit, transpile, assemble, Aer # Elementos b√°sicos de Qiskit
    from qiskit.result import Result # Para tipagem do resultado
    # TODO: Importar classes para mitiga√ß√£o de ru√≠do, compila√ß√£o qu√¢ntica adaptada
    # from qiskit.transpiler import PassManager
    # from qiskit_aer.noise import NoiseModel
    # from qiskit.utils.mitigation import zne
    IBM_QUANTUM_AVAILABLE = True
except ImportError:
    IBM_QUANTUM_AVAILABLE = False
    # app_logger.warning("DPR_QUANTUM_CORE: Bibliotecas Qiskit n√£o instaladas. Funcionalidade qu√¢ntica indispon√≠vel.")


from app.utils.logging_config import log_audit # Importa o logger de auditoria
# from app.core.config import load_config # Importar config para par√¢metros qu√¢nticos (evitar import circular se poss√≠vel)


app_logger = logging.getLogger("DPR_QUANTUM_CORE")

class QuantumCore:
    """
    Gerenciador Central para Execu√ß√£o de Circuitos Qu√¢nticos Propriet√°rios.
    Orquestra a intera√ß√£o com backends IBM Quantum ou simuladores locais.
    """
    _provider: IBMProvider = None
    _backend = None # Backend (hardware ou simulador)
    _simulator: AerSimulator = None
    _is_initialized: bool = False
    _initialization_error: str = None
    _config_ref: dict = None # Refer√™ncia √† configura√ß√£o

    @classmethod
    def initialize(cls, config: dict):
        """
        Inicializa o Core Qu√¢ntico, configurando o provedor e o backend alvo.
        Chamado durante a inicializa√ß√£o da aplica√ß√£o.
        """
        if cls._is_initialized:
            app_logger.debug("DPR_QUANTUM_CORE: QuantumCore j√° inicializado.")
            return

        cls._config_ref = config
        cls._initialization_error = None # Reset error

        if not IBM_QUANTUM_AVAILABLE:
            cls._initialization_error = "Bibliotecas Qiskit n√£o instaladas. Funcionalidade qu√¢ntica indispon√≠vel."
            app_logger.critical(f"DPR_QUANTUM_CORE_FATAL: {cls._initialization_error}")
            log_audit(logging.CRITICAL, "Inicializa√ß√£o do Core Qu√¢ntico falhou.", event_type="QUANTUM_INIT_FAILED", reason="QISKIT_NOT_INSTALLED")
            cls._is_initialized = False
            return

        ibm_token = config.get("DPR_IBM_QUANTUM_TOKEN")
        ibm_instance = config.get("DPR_IBM_QUANTUM_INSTANCE")
        ibm_backend_name = config.get("DPR_IBM_QUANTUM_BACKEND")
        ibm_simulator_name = config.get("DPR_IBM_QUANTUM_SIMULATOR", "aer_simulator") # Default simulador AER
        quantum_mode = config.get("DPR_QUANTUM_EXECUTION_MODE", "simulator")

        # 1. Inicializar Simulador AER (sempre tentamos)
        app_logger.info(f"DPR_QUANTUM_CORE: Inicializando simulador AER: {ibm_simulator_name}")
        try:
             cls._simulator = AerSimulator() # Pode ser Aer.get_backend(ibm_simulator_name)
             app_logger.info("DPR_QUANTUM_CORE_SUCCESS: Simulador AER inicializado.")
        except Exception as e:
             app_logger.error(f"DPR_QUANTUM_CORE_ERROR: Falha ao inicializar simulador AER: {e!s}", exc_info=True)
             log_audit(logging.ERROR, "Inicializa√ß√£o do simulador AER falhou.", event_type="QUANTUM_INIT_FAILED", backend="aer_simulator", error=str(e))
             cls._simulator = None # Garante que √© None em caso de falha

        # 2. Inicializar Provedor e Backend IBM Quantum (se modo hardware)
        if quantum_mode == "hardware":
            app_logger.info(f"DPR_QUANTUM_CORE: Inicializando IBM Quantum Provider para modo 'hardware'...")
            # Verificar se as configura√ß√µes cr√≠ticas para hardware est√£o presentes e seguras
            if not ibm_token or not ibm_instance or not ibm_backend_name:
                cls._initialization_error = "Configura√ß√µes IBM Quantum (token, instance, backend) incompletas/inseguras para modo 'hardware'."
                app_logger.fatal(f"DPR_QUANTUM_CORE_FATAL: {cls._initialization_error}")
                log_audit(logging.CRITICAL, "Inicializa√ß√£o do Core Qu√¢ntico falhou: Configura√ß√µes incompletas/inseguras para hardware.", event_type="QUANTUM_INIT_FAILED", reason="HARDWARE_CONFIG_INCOMPLETE")
                # Permite a inicializa√ß√£o se o simulador estiver dispon√≠vel, mas o hardware falha
                if cls._simulator is not None:
                    cls._is_initialized = True # Core inicializado com simulador como fallback
                    app_logger.warning("DPR_QUANTUM_CORE_WARN: Hardware IBM Quantum indispon√≠vel devido a configura√ß√£o. Usando simulador como fallback.")
                else:
                     cls._is_initialized = False # Core completamente inoperante
                     log_audit(logging.CRITICAL, "Inicializa√ß√£o do Core Qu√¢ntico falhou: Hardware (config) E simulador indispon√≠veis.", event_type="QUANTUM_INIT_FAILED", reason="NO_QUANTUM_BACKEND_AVAILABLE")
                return # Finaliza a inicializa√ß√£o (sucesso parcial ou falha)


            try:
                 # Autenticar com o provedor IBM Quantum
                 # IBMProvider.save_account(token=ibm_token, instance=ibm_instance, overwrite=True) # Pode ser feito externamente
                 cls._provider = IBMProvider(token=ibm_token, instance=ibm_instance) # Usar token/instance diretamente

                 # Opcional: Usar least_busy para encontrar um backend dispon√≠vel
                 # from qiskit.providers.provider_exceptions import NoQubits
                 # try:
                 #     large_enough_qubits = 15 # Exemplo, ajustar conforme necessidade do circuito
                 #     cls._backend = least_busy(cls._provider.backends(
                 #          filters=lambda b: b.configuration().n_qubits >= large_enough_qubits
                 #          and not b.configuration().simulator # Certifica que n√£o √© simulador
                 #          and b.status().operational == True),
                 #          retired=False
                 #     )
                 #     ibm_backend_name = cls._backend.name # Atualiza nome se usou least_busy
                 #     app_logger.info(f"DPR_QUANTUM_CORE: Least busy IBM Quantum backend found: '{ibm_backend_name}'.")
                 # except NoQubits:
                 #      app_logger.warning(f"DPR_QUANTUM_CORE_WARN: Nenhum backend IBM Quantum operacional com {large_enough_qubits}+ qubits encontrado.")
                 #      cls._backend = None # Define como None se n√£o encontrar

                 # Carregar o backend espec√≠fico configurado
                 if cls._backend is None: # Se least_busy n√£o encontrou ou n√£o foi usado
                     cls._backend = cls._provider.get_backend(ibm_backend_name)
                     app_logger.info(f"DPR_QUANTUM_CORE_SUCCESS: Backend IBM Quantum '{ibm_backend_name}' carregado.")

                 # Verificar se o backend est√° operacional
                 if cls._backend is not None and not cls._backend.status().operational:
                      app_logger.warning(f"DPR_QUANTUM_CORE_WARN: Backend IBM Quantum '{ibm_backend_name}' n√£o est√° operacional no momento.")
                      cls._backend = None # Tratar como indispon√≠vel

                 if cls._backend is None:
                     cls._initialization_error = f"Backend IBM Quantum '{ibm_backend_name}' n√£o dispon√≠vel ou n√£o operacional."
                     app_logger.fatal(f"DPR_QUANTUM_CORE_FATAL: {cls._initialization_error}")
                     log_audit(logging.CRITICAL, "Inicializa√ß√£o do Core Qu√¢ntico falhou: Backend de hardware indispon√≠vel/n√£o operacional.", event_type="QUANTUM_INIT_FAILED", backend=ibm_backend_name)
                     # Permite a inicializa√ß√£o se o simulador estiver dispon√≠vel, mas o hardware falha
                     if cls._simulator is not None:
                         cls._is_initialized = True # Core inicializado com simulador como fallback
                         app_logger.warning("DPR_QUANTUM_CORE_WARN: Hardware IBM Quantum indispon√≠vel. Usando simulador como fallback.")
                     else:
                          cls._is_initialized = False # Core completamente inoperante
                          log_audit(logging.CRITICAL, "Inicializa√ß√£o do Core Qu√¢ntico falhou: Hardware E simulador indispon√≠veis.", event_type="QUANTUM_INIT_FAILED", reason="NO_QUANTUM_BACKEND_AVAILABLE")
                     return # Finaliza a inicializa√ß√£o (sucesso parcial ou falha)


                 app_logger.info(f"DPR_QUANTUM_CORE_SUCCESS: IBM Quantum Provider e Backend '{ibm_backend_name}' inicializados com sucesso.")
                 log_audit(logging.INFO, "IBM Quantum Provider e Backend inicializados.", event_type="QUANTUM_INIT_SUCCESS", backend=ibm_backend_name)

            except Exception as e:
                cls._initialization_error = f"Falha na inicializa√ß√£o do IBM Quantum Provider ou Backend: {e!s}"
                app_logger.fatal(f"DPR_QUANTUM_CORE_FATAL: {cls._initialization_error}", exc_info=True)
                log_audit(logging.CRITICAL, "Inicializa√ß√£o do Core Qu√¢ntico falhou: Erro no Provider/Backend IBM.", event_type="QUANTUM_INIT_FAILED", reason="IBM_PROVIDER_ERROR", error=str(e))
                cls._provider = None
                cls._backend = None
                # Permite a inicializa√ß√£o se o simulador estiver dispon√≠vel como fallback
                if cls._simulator is not None:
                     cls._is_initialized = True # Core inicializado com simulador como fallback
                     app_logger.warning("DPR_QUANTUM_CORE_WARN: Hardware IBM Quantum indispon√≠vel devido a erro. Usando simulador como fallback.")
                else:
                     cls._is_initialized = False # Core completamente inoperante
                     log_audit(logging.CRITICAL, "Inicializa√ß√£o do Core Qu√¢ntico falhou: Erro no Provider/Backend IBM E simulador indispon√≠vel.", event_type="QUANTUM_INIT_FAILED", reason="NO_QUANTUM_BACKEND_AVAILABLE_AFTER_ERROR")
                return # Finaliza a inicializa√ß√£o (sucesso parcial ou falha)

        # 3. Finalizar inicializa√ß√£o
        if cls._simulator is not None or cls._backend is not None:
            cls._is_initialized = True
            app_logger.info("DPR_QUANTUM_CORE_SUCCESS: QuantumCore inicializado. Pelo menos um backend (simulador ou hardware) est√° dispon√≠vel.")
        else:
            cls._is_initialized = False
            cls._initialization_error = "Nenhum backend qu√¢ntico (simulador ou hardware) p√¥de ser inicializado."
            app_logger.fatal(f"DPR_QUANTUM_CORE_FATAL: {cls._initialization_error}")
            log_audit(logging.CRITICAL, "Inicializa√ß√£o do Core Qu√¢ntico falhou: Nenhum backend dispon√≠vel.", event_type="QUANTUM_INIT_FAILED", reason="NO_BACKEND_AVAILABLE")


    # --- VERIFICA STATUS DE DISPONIBILIDADE ---
    @classmethod
    def is_available(cls) -> bool:
        """Retorna True se o QuantumCore foi inicializado e tem pelo menos um backend dispon√≠vel."""
        return cls._is_initialized and (cls._simulator is not None or cls._backend is not None)

    @classmethod
    def get_initialization_error(cls) -> str | None:
        """Retorna a mensagem de erro se a inicializa√ß√£o falhou."""
        return cls._initialization_error

    # --- OBT√âM BACKEND ATUAL ---
    @classmethod
    def _get_current_backend(cls):
         """
         Retorna o backend qu√¢ntico a ser usado, priorizando hardware se configurado
         e dispon√≠vel, caso contr√°rio, usando o simulador.
         """
         if not cls._is_initialized:
              app_logger.error("DPR_QUANTUM_CORE_ERROR: Tentativa de obter backend, mas QuantumCore n√£o inicializado.")
              return None

         quantum_mode = cls._config_ref.get("DPR_QUANTUM_EXECUTION_MODE", "simulator")

         if quantum_mode == "hardware" and cls._backend is not None:
              if not cls._backend.status().operational: # Verifica status operacional antes de usar
                  app_logger.warning(f"DPR_QUANTUM_CORE_WARN: Backend de hardware '{cls._backend.name}' n√£o est√° operacional. Falhando ou tentando fallback.")
                  if cls._simulator is not None:
                      app_logger.warning("DPR_QUANTUM_CORE_WARN: Usando simulador AER como fallback para hardware inoperante.")
                      return cls._simulator
                  else:
                      app_logger.error("DPR_QUANTUM_CORE_ERROR: Backend de hardware inoperante e simulador n√£o dispon√≠vel.")
                      return None
              return cls._backend # Usa hardware se operacional
         elif cls._simulator is not None:
              return cls._simulator # Usa simulador
         else:
              app_logger.error("DPR_QUANTUM_CORE_ERROR: Nenhum backend qu√¢ntico dispon√≠vel.")
              return None


    # --- EXECUTA CIRCUITO QU√ÇNTICO ---
    @classmethod
    def execute_quantum_circuit(cls, quantum_circuit: QuantumCircuit, shots: int | None = None, user_id="N/A", device_id="N/A", request_id="N/A") -> dict | None:
        """
        Executa um QuantumCircuit no backend qu√¢ntico configurado.
        Aplica transpile, mitiga√ß√£o de ru√≠do (se hardware) e obt√©m contagens.

        Args:
            quantum_circuit (QuantumCircuit): O circuito qu√¢ntico a ser executado.
            shots (int, optional): N√∫mero de execu√ß√µes do circuito. Defaults to configured value.
            user_id (str): ID do usu√°rio (para logs).
            device_id (str): ID do dispositivo (para logs).
            request_id (str): ID da requisi√ß√£o (para logs).

        Returns:
            dict: O dicion√°rio de contagens do resultado das medi√ß√µes, ou None em caso de falha.
        """
        if not cls.is_available():
            app_logger.error(f"DPR_QUANTUM_CORE_ERROR: Core Qu√¢ntico n√£o dispon√≠vel para execu√ß√£o de circuito para user '{user_id}', request '{request_id}'.")
            log_audit(logging.ERROR, "Execu√ß√£o de circuito qu√¢ntico falhou: Core Qu√¢ntico indispon√≠vel.", event_type="QUANTUM_EXECUTION_FAILED", reason="QUANTUM_CORE_UNAVAILABLE", user_id=user_id, device_id=device_id, request_id=request_id)
            return None

        backend = cls._get_current_backend()
        if backend is None:
            app_logger.error(f"DPR_QUANTUM_CORE_ERROR: Nenhum backend qu√¢ntico dispon√≠vel ou operacional para execu√ß√£o de circuito para user '{user_id}', request '{request_id}'.")
            log_audit(logging.ERROR, "Execu√ß√£o de circuito qu√¢ntico falhou: Nenhum backend dispon√≠vel.", event_type="QUANTUM_EXECUTION_FAILED", reason="NO_BACKEND_AVAILABLE_FOR_EXECUTION", user_id=user_id, device_id=device_id, request_id=request_id)
            return None

        # Obter shots da config se n√£o especificado
        if shots is None:
             shots = cls._config_ref.get("DPR_INFERENCE_PARAMS", {}).get("quantum", {}).get("shots", 8192)


        backend_name = backend.name
        app_logger.info(f"DPR_QUANTUM_CORE: Iniciando execu√ß√£o de circuito em '{backend_name}' (shots={shots}) para user '{user_id}', request '{request_id}'.")
        log_audit(logging.INFO, "Execu√ß√£o de circuito qu√¢ntico iniciada.", event_type="QUANTUM_EXECUTION_START", user_id=user_id, device_id=device_id, request_id=request_id, backend=backend_name, shots=shots)

        try:
            # TODO: Implementar transpile avan√ßado com otimiza√ß√µes customizadas e mitiga√ß√£o de ru√≠do
            # A transplica√ß√£o √© essencial para adaptar o circuito ao hardware.
            # Mitigation de ru√≠do √© CR√çTICA para resultados em hardware NISQ.
            
            # --- COMPILAR CIRCUITO PARA O BACKEND ALVO ---
            # Exemplo b√°sico de transpila√ß√£o
            compiled_circuit = transpile(quantum_circuit, backend=backend, optimization_level=1) # Ajustar opt_level

            # TODO: Aplicar t√©cnicas de MITIGA√á√ÉO DE RU√çDO se o backend for hardware REAL.
            # Isso envolve envolver o circuito compilado em protocolos de mitiga√ß√£o (ZNE, PEC, etc.)
            # compiled_circuit_for_mitigation = apply_noise_mitigation_protocol(compiled_circuit, backend)

            # --- EXECUTAR O CIRCUITO ---
            # Em um sistema real de produ√ß√£o, jobs de hardware s√£o ASS√çNCRONOS.
            # job = backend.run(compiled_circuit_for_mitigation, shots=shots) # Executa o job
            # job_id = job.job_id()
            # app_logger.info(f"... Job submission complete. Job ID: {job_id}")
            # return {"status": "submitted", "job_id": job_id} # Retornaria um status e ID do job

            # PARA ESTE EXEMPLO, USAMOS EXECU√á√ÉO S√çNCRONA PARA SIMPLICIDADE (funciona bem para simulador)
            app_logger.debug("DPR_QUANTUM_CORE: (S√≠ncrono) Aguardando resultados do job...")
            job = backend.run(compiled_circuit, shots=shots) # Execu√ß√£o s√≠ncrona/poll
            result: Result = job.result()

            # --- OBTER RESULTADOS (CONTAMENTOS) ---
            # get_counts pode aplicar mitiga√ß√£o de erros de medi√ß√£o se configurado no job/backend.
            counts = result.get_counts(quantum_circuit) # Get counts for the ORIGINAL circuit (mitigation applied implicitly/explicitly)

            # TODO: Aplicar P√ìS-PROCESSAMENTO/DECODIFICA√á√ÉO/MITIGA√á√ÉO FINAL nos resultados se necess√°rio
            # counts_mitigated = apply_post_processing_and_mitigation(counts, result, backend)

            app_logger.info(f"DPR_QUANTUM_CORE_SUCCESS: Execu√ß√£o de circuito conclu√≠da e resultados obtidos para user '{user_id}', request '{request_id}'.")
            log_audit(logging.INFO, "Execu√ß√£o de circuito qu√¢ntico conclu√≠da com sucesso.", event_type="QUANTUM_EXECUTION_COMPLETE", user_id=user_id, device_id=device_id, request_id=request_id, backend=backend_name, shots=shots, counts_preview=str(counts)[:200]) # Log preview das contagens

            return counts # Retorna o dicion√°rio de contagens mitigadas/processadas

        except Exception as e:
            app_logger.error(f"DPR_QUANTUM_CORE_ERROR: Erro durante a execu√ß√£o do circuito qu√¢ntico em '{backend_name}' para user '{user_id}', request '{request_id}': {e!s}", exc_info=True)
            log_audit(logging.ERROR, "Erro durante a execu√ß√£o qu√¢ntica.", event_type="QUANTUM_EXECUTION_FAILED", user_id=user_id, device_id=device_id, request_id=request_id, error=str(e), backend=backend_name)
            return None # Indica falha


    # TODO: Adicionar m√©todos para gerenciar jobs ass√≠ncronos, se implementado acima.
    # @classmethod
    # def get_job_result(cls, job_id: str):
    #      """Obt√©m o resultado de um job qu√¢ntico submetido assincronamente."""
    #      ... (l√≥gica para recuperar job do provider e retornar resultado/status)


# TODO: M√≥dulo ou classes separadas para definir a L√ìGICA dos Circuitos Qu√¢nticos Espec√≠ficos
# Ex: wellbeing_qnn.py, qaoa_optimizer.py
# Estes m√≥dulos construiriam o objeto QuantumCircuit usando dados de entrada,
# e ent√£o CHAMARIAM QuantumCore.execute_quantum_circuit para rod√°-lo.

# Exemplo CONCEITUAL de como a L√≥gica Qu√¢ntica Propriet√°ria construiria e usaria um circuito:
# def build_my_proprietary_wellbeing_qnn(features: dict, qnn_params: dict) -> QuantumCircuit:
#      """Constr√≥i o circuito QNN propriet√°rio para predi√ß√£o de bem-estar."""
#      # TODO: Mapear features para par√¢metros de codifica√ß√£o qu√¢ntica.
#      # TODO: Construir circuito de Codifica√ß√£o Qu√¢ntica (S(x)).
#      # TODO: Construir circuito Variacional (V(theta)) com camadas de rota√ß√£o e emaranhamento.
#      # TODO: Combinar S(x) e V(theta).
#      # TODO: Adicionar medi√ß√µes ao final.
#      n_qubits = len(features) # Exemplo simplista
#      qc = QuantumCircuit(n_qubits, n_qubits)
#      # Add encoding based on features...
#      # Add variational layers based on qnn_params...
#      qc.measure(list(range(n_qubits)), list(range(n_qubits))) # Medir todos
#      return qc

# def decode_qnn_results(counts: dict) -> float:
#      """Decodifica o resultado (contagens) do QNN para obter a predi√ß√£o de bem-estar."""
#      # TODO: Implementar l√≥gica para converter contagens em probabilidade/score cl√°ssico.
#      # Isso pode envolver c√°lculo de expectativa de observ√°vel a partir das contagens.
#      # Ex: probabilidade_estado_00 = counts.get('00', 0) / sum(counts.values()) # Exemplo trivial 2-qubits
#      # Mapear para risco de crise...
#      return 0.5 # Probabilidade de risco simulada

# Nota: A l√≥gica REAL dos algoritmos QML/QAOA/VQE e o treinamento H√≠brido CL√ÅSSICO-QU√ÇNTICO
# reside NESTA Camada Propriet√°ria (outros arquivos dentro de models.proprietary ou core).
# QuantumCore APENAS executa circuitos e lida com o backend.

# ==========¬©====DON=====¬Æ==========
# FIM DO ARQUIVO app/core/quantum_core.py
# SELADO SOB AUTORIDADE DPR.
```
```python
# -*- coding: utf-8 -*-
#
# üúÇ REGENERA A.I.¬Æ BACKEND - EDI√á√ÉO SOBERANA IMPERIAL DEFINITIVA V10.10 üúÇ
# üúÑ ARQUIVO: app/models/proprietary/__init__.py üúÑ
#
# N√∫cleo de Modelagem Propriet√°ria DPR¬Æ - Inicializador de M√≥dulos.
# Desenvolvido por Paulo Ricardo de Le√£o.
#
# Este arquivo inicializa o namespace para os Modelos de IA Propriet√°rios
# (TLM, TSV, TAS, e Conceitos Qu√¢nticos Pr√≥prios).
#
# A implementa√ß√£o REAL dos algoritmos, arquiteturas e l√≥gica de infer√™ncia reside
# nos arquivos Python espec√≠ficos dentro deste diret√≥rio (`proprietary/`).
# O Core Qu√¢ntico est√° em `app/core/quantum_core.py`.
# O carregamento destas classes e inst√¢ncias √© orquestrado por `app/core/models.py`.
#
# ==========¬©====DON=====¬Æ==========

# Este arquivo '__init__.py' serve primariamente para marcar o diret√≥rio 'proprietary'
# como um pacote Python e permitir que os m√≥dulos dentro dele sejam importados
# por `app.core.models`.
# Nenhuma l√≥gica de inicializa√ß√£o complexa deve residir aqui.

# Metadata sobre o pacote propriet√°rio
__version__ = "1.0.DPR_AUTORAL"
__author__ = "Paulo Ricardo de Le√£o"
__copyright__ = "Copyright ¬© 2024-2025 Paulo Ricardo de Le√£o"
__status__ = "Soberano e Autorizado por DPR"

# Ao carregar classes dinamicamente em `app.core.models`, garantimos
# que os arquivos de modelo (`tlm_model.py`, etc.) s√£o importados no runtime,
# onde as classes `ProprietaryTLM`, `ProprietaryTSV`, `ProprietaryTAS`, etc.,
# estar√£o definidas.


# ==========¬©====DON=====¬Æ==========
# FIM DO ARQUIVO app/models/proprietary/__init__.py
# SELADO SOB AUTORIDADE DPR.
```
```python
# -*- coding: utf-8 -*-
#
# üúÇ REGENERA A.I.¬Æ BACKEND - EDI√á√ÉO SOBERANA IMPERIAL DEFINITIVA V10.10 üúÇ
# üúÑ ARQUIVO: app/models/proprietary/tlm_model.py üúÑ
#
# Modelo de Linguagem Transcendente (TLM) Propriet√°rio DPR¬Æ.
# Desenvolvido por Paulo Ricardo de Le√£o.
#
# Este arquivo define a estrutura para o Modelo de Linguagem Propriet√°rio,
# respons√°vel pela gera√ß√£o de texto. A implementa√ß√£o dos algoritmos de aprendizado,
# a arquitetura neural, os pesos treinados e a l√≥gica de infer√™ncia residem aqui.
#
# ==========¬©====DON=====¬Æ==========

import logging
import os

app_logger = logging.getLogger("DPR_PROPRIETARY_TLM")

class ProprietaryTLM:
    """
    Classe para o Modelo de Linguagem Transcendente (TLM).
    Cont√©m a l√≥gica para carregar o modelo treinado e realizar infer√™ncia de texto.
    """
    _model_instance = None # Pode ser a inst√¢ncia de um modelo carregado (ex: Tua pr√≥pria NN em PyTorch/TensorFlow)

    def __init__(self, model_path: str, inference_params: dict):
        """
        Inicializa o modelo TLM, carregando os pesos treinados do arquivo especificado.

        Args:
            model_path (str): Caminho para o arquivo do modelo TLM treinado (.dpr_tlm).
            inference_params (dict): Par√¢metros de infer√™ncia (max_tokens, temperature, etc.).
        """
        self.model_path = model_path
        self.inference_params = inference_params
        self.is_loaded = False

        app_logger.info(f"DPR_PROPRIETARY_TLM: Tentando inicializar modelo TLM de: {self.model_path}")

        # --- CARREGAR O MODELO TLM ---
        if not os.path.exists(self.model_path):
             app_logger.error(f"DPR_PROPRIETARY_TLM_ERROR: Arquivo do modelo TLM n√£o encontrado: {self.model_path}")
             self.is_loaded = False # Explicitamente False em caso de falha no arquivo
             raise FileNotFoundError(f"Arquivo do modelo TLM propriet√°rio n√£o encontrado em: {self.model_path}") # Levanta erro para ModelsManager tratar

        try:
            # TODO: Implementar a l√≥gica REAL para carregar o modelo TLM treinado.
            # Ex: carregar pesos de um arquivo serializado, inicializar a arquitetura.
            # Isso √© espec√≠fico da Tua implementa√ß√£o algor√≠tmica.
            # Exemplo conceitual:
            # self._model_instance = load_my_trained_tlm_model(self.model_path)
            
            # Placeholder: Representa o carregamento bem-sucedido
            app_logger.info(f"DPR_PROPRIETARY_TLM: Representando carregamento do modelo TLM de: {self.model_path}")
            self._model_instance = {"name": "MeuTLMv1", "status": "loaded"} # Representa a inst√¢ncia do modelo
            
            self.is_loaded = True
            app_logger.info("DPR_PROPRIETARY_TLM_SUCCESS: Modelo TLM carregado com sucesso.")

        except Exception as e:
            app_logger.error(f"DPR_PROPRIETARY_TLM_ERROR: Falha ao carregar modelo TLM: {e!s}", exc_info=True)
            self._model_instance = None
            self.is_loaded = False
            raise RuntimeError(f"Falha cr√≠tica ao carregar modelo TLM: {e!s}") # Levanta erro para ModelsManager tratar

    # --- M√âTODO DE INFER√äNCIA PARA GERA√á√ÉO DE TEXTO ---
    def generate(self, prompt: str, user_id: str = "N/A", request_id: str = "N/A", dynamic_params: dict = None) -> str:
        """
        Gera texto usando o Modelo de Linguagem Propriet√°rio.

        Args:
            prompt (str): O prompt de entrada para gera√ß√£o de texto.
            user_id (str): ID do usu√°rio associado √† requisi√ß√£o (para logs).
            request_id (str): ID da requisi√ß√£o (para logs).
            dynamic_params (dict, optional): Par√¢metros de infer√™ncia din√¢micos por requisi√ß√£o.

        Returns:
            str: O texto gerado ou None em caso de erro.
        """
        if not self.is_loaded or self._model_instance is None:
            app_logger.error(f"DPR_PROPRIETARY_TLM_ERROR: Tentativa de gerar texto, mas modelo TLM n√£o est√° carregado para user '{user_id}', request '{request_id}'.")
            return None

        app_logger.info(f"DPR_PROPRIETARY_TLM: Realizando infer√™ncia TLM para user '{user_id}', request '{request_id}' (prompt: {prompt[:100]}...)")

        # Combinar par√¢metros padr√£o com par√¢metros din√¢micos
        current_params = self.inference_params.copy()
        if dynamic_params:
            current_params.update(dynamic_params)
            app_logger.debug(f"DPR_PROPRIETARY_TLM: Usando par√¢metros din√¢micos: {dynamic_params}")

        try:
            # TODO: Implementar a l√≥gica REAL de infer√™ncia usando o modelo TLM.
            # Usa current_params para controlar a gera√ß√£o.
            # Ex: output = self._model_instance.predict(prompt, **current_params)

            # Placeholder: Representa a gera√ß√£o de texto baseada no prompt e par√¢metros
            simulated_output = f"Resposta da Regenera A.I. (TLM) para: '{prompt[:100]}...'. Par√¢metros usados: {current_params}"
            
            app_logger.info(f"DPR_PROPRIETARY_TLM_SUCCESS: Infer√™ncia TLM conclu√≠da para user '{user_id}', request '{request_id}'.")
            return simulated_output # Retorna o texto gerado (representa√ß√£o)

        except Exception as e:
            app_logger.error(f"DPR_PROPRIETARY_TLM_ERROR: Erro durante a infer√™ncia do modelo TLM para user '{user_id}', request '{request_id}': {e!s}", exc_info=True)
            return None

    # TODO: Adicionar m√©todo para an√°lise emocional estruturada se for parte deste modelo
    # def analyze_emotion(self, text: str) -> dict:
    #     """Realiza an√°lise emocional estruturada do texto."""
    #     # TODO: Implementar l√≥gica de an√°lise emocional
    #     return {"sentiment_score": 0.7, "emotion_tags": ["positive", "calm"]} # Representa√ß√£o

# TODO: Implementar as classes ProprietaryTSV e ProprietaryTAS de forma similar em seus arquivos dedicados.

# ==========¬©====DON=====¬Æ==========
# FIM DO ARQUIVO app/models/proprietary/tlm_model.py
# SELADO SOB AUTORIDADE DPR.
```
```python
# -*- coding: utf-8 -*-
#
# üúÇ REGENERA A.I.¬Æ BACKEND - EDI√á√ÉO SOBERANA IMPERIAL DEFINITIVA V10.10 üúÇ
# üúÑ ARQUIVO: app/models/proprietary/tsv_model.py üúÑ
#
# Modelo de S√≠ntese de Voz Transcendente (TSV) Propriet√°rio DPR¬Æ.
# Desenvolvido por Paulo Ricardo de Le√£o.
#
# Este arquivo define a estrutura para o Modelo de S√≠ntese de Voz Propriet√°rio,
# respons√°vel por gerar fala a partir de texto, utilizando a Voz Exclusiva DPR¬Æ.
# A implementa√ß√£o dos algoritmos e a l√≥gica de infer√™ncia residem aqui.
#
# ==========¬©====DON=====¬Æ==========

import logging
import os
import numpy as np
import soundfile as sf # Necess√°rio para manipular √°udio em arquivos (ex: speaker_wav)
import io # Para gerar bytes de √°udio em mem√≥ria

app_logger = logging.getLogger("DPR_PROPRIETARY_TSV")

class ProprietaryTSV:
    """
    Classe para o Modelo de S√≠ntese de Voz Transcendente (TSV).
    Cont√©m a l√≥gica para carregar o modelo treinado e realizar infer√™ncia de fala.
    Utiliza a Voz Exclusiva DPR¬Æ como refer√™ncia.
    """
    _model_instance = None # Pode ser a inst√¢ncia de um modelo carregado
    _speaker_reference_audio = None # Dados de √°udio da Voz Exclusiva DPR¬Æ
    _speaker_sample_rate = None # Sample rate do √°udio de refer√™ncia

    def __init__(self, model_path: str, speaker_wav_reference: str, inference_params: dict):
        """
        Inicializa o modelo TSV, carregando pesos e √°udio de refer√™ncia.

        Args:
            model_path (str): Caminho para o arquivo do modelo TSV treinado (.dpr_tsv).
            speaker_wav_reference (str): Caminho para o arquivo WAV da Voz Exclusiva DPR¬Æ.
            inference_params (dict): Par√¢metros de infer√™ncia (language, etc.).
        """
        self.model_path = model_path
        self.speaker_wav_reference = speaker_wav_reference
        self.inference_params = inference_params
        self.is_loaded = False

        app_logger.info(f"DPR_PROPRIETARY_TSV: Tentando inicializar modelo TSV de: {self.model_path}")

        # --- CARREGAR O MODELO TSV ---
        if not os.path.exists(self.model_path):
             app_logger.error(f"DPR_PROPRIETARY_TSV_ERROR: Arquivo do modelo TSV n√£o encontrado: {self.model_path}")
             raise FileNotFoundError(f"Arquivo do modelo TSV propriet√°rio n√£o encontrado em: {self.model_path}")

        try:
            # TODO: Implementar a l√≥gica REAL para carregar o modelo TSV treinado.
            # Ex: carregar pesos, inicializar a arquitetura.
            # self._model_instance = load_my_trained_tsv_model(self.model_path)

            # Placeholder: Representa o carregamento bem-sucedido
            app_logger.info(f"DPR_PROPRIETARY_TSV: Representando carregamento do modelo TSV de: {self.model_path}")
            self._model_instance = {"name": "MeuTSVv1", "status": "loaded"} # Representa a inst√¢ncia

            # --- CARREGAR √ÅUDIO DE REFER√äNCIA DA VOZ EXCLUSIVA DPR¬Æ ---
            if not os.path.exists(self.speaker_wav_reference):
                 app_logger.error(f"DPR_PROPRIETARY_TSV_ERROR: Arquivo de refer√™ncia da Voz Exclusiva DPR¬Æ n√£o encontrado: {self.speaker_wav_reference}")
                 # Levanta erro FATAL, pois a voz exclusiva √© essencial para TSV DPR
                 raise FileNotFoundError(f"Arquivo da Voz Exclusiva DPR¬Æ n√£o encontrado em: {self.speaker_wav_reference}")

            # Carregar √°udio de refer√™ncia usando soundfile (ou Tua biblioteca propriet√°ria)
            try:
                # Retorna numpy array e sample rate
                self._speaker_reference_audio, self._speaker_sample_rate = sf.read(self.speaker_wav_reference)
                app_logger.info(f"DPR_PROPRIETARY_TSV_SUCCESS: √Åudio da Voz Exclusiva DPR¬Æ carregado. SR: {self._speaker_sample_rate}")
                
            except Exception as e:
                 app_logger.error(f"DPR_PROPRIETARY_TSV_ERROR: Falha ao carregar √°udio da Voz Exclusiva DPR¬Æ: {e!s}", exc_info=True)
                 raise RuntimeError(f"Falha cr√≠tica ao carregar √°udio da Voz Exclusiva DPR¬Æ: {e!s}")


            self.is_loaded = True
            app_logger.info("DPR_PROPRIETARY_TSV_SUCCESS: Modelo TSV e √°udio de refer√™ncia carregados com sucesso.")

        except Exception as e:
            app_logger.error(f"DPR_PROPRIETARY_TSV_ERROR: Falha ao inicializar modelo TSV ou carregar refer√™ncia: {e!s}", exc_info=True)
            self._model_instance = None
            self._speaker_reference_audio = None
            self.is_loaded = False
            raise RuntimeError(f"Falha cr√≠tica na inicializa√ß√£o do modelo TSV: {e!s}") # Levanta erro para ModelsManager tratar


    # --- M√âTODO DE INFER√äNCIA PARA GERA√á√ÉO DE FALA ---
    def synthesize(self, text: str, user_id: str = "N/A", request_id: str = "N/A", dynamic_params: dict = None) -> bytes:
        """
        Gera fala a partir de texto usando o Modelo de S√≠ntese de Voz Propriet√°rio.

        Args:
            text (str): O texto de entrada para s√≠ntese de fala.
            user_id (str): ID do usu√°rio associado √† requisi√ß√£o (para logs).
            request_id (str): ID da requisi√ß√£o (para logs).
            dynamic_params (dict, optional): Par√¢metros de infer√™ncia din√¢micos por requisi√ß√£o.

        Returns:
            bytes: Dados de √°udio em formato WAV (bytes) ou None em caso de erro.
        """
        if not self.is_loaded or self._model_instance is None or self._speaker_reference_audio is None:
            app_logger.error(f"DPR_PROPRIETARY_TSV_ERROR: Tentativa de gerar fala, mas modelo TSV, √°udio de refer√™ncia ou depend√™ncias n√£o est√£o carregados para user '{user_id}', request '{request_id}'.")
            return None

        app_logger.info(f"DPR_PROPRIETARY_TSV: Realizando infer√™ncia TSV para user '{user_id}', request '{request_id}' (texto: {text[:100]}...)")

        # Combinar par√¢metros padr√£o com par√¢metros din√¢micos
        current_params = self.inference_params.copy()
        if dynamic_params:
            current_params.update(dynamic_params)
            app_logger.debug(f"DPR_PROPRIETARY_TSV: Usando par√¢metros din√¢micos: {dynamic_params}")


        try:
            # TODO: Implementar a l√≥gica REAL de infer√™ncia usando o modelo TSV.
            # Usa current_params (ex: language) e self._speaker_reference_audio/rate.
            # A sa√≠da DEVE ser um array numpy de √°udio (float32 recomendado).
            # Ex: audio_np_array = self._model_instance.generate_audio(text, self._speaker_reference_audio, **current_params)

            # Placeholder: Representa a gera√ß√£o de √°udio (um simples beep + som)
            app_logger.info(f"DPR_PROPRIETARY_TSV: Representando gera√ß√£o de √°udio com TSV.")
            sample_rate = self._speaker_sample_rate or 22050 # Usar SR da refer√™ncia ou default
            duration = 2 # Dura√ß√£o em segundos
            frequency = 440 # Frequ√™ncia do beep em Hz
            t = np.linspace(0., duration, int(sample_rate * duration))
            # Uma representa√ß√£o um pouco mais elaborada: Tom de voz "DPR"
            dpr_tone = 0.6 * np.sin(2 * np.pi * 150 * t) + 0.4 * np.sin(2 * np.pi * 250 * t)
            # Adicionar ru√≠do controlado para representar "Voz DPR"
            controlled_noise = 0.05 * np.random.randn(len(t))
            simulated_audio_np = dpr_tone + controlled_noise

            # Garante que est√° no range float32 [-1.0, 1.0]
            simulated_audio_np = np.clip(simulated_audio_np, -1.0, 1.0).astype(np.float32)

            # Converter o array numpy para bytes WAV
            buffer = io.BytesIO()
            sf.write(buffer, simulated_audio_np, sample_rate, format='WAV')
            wav_bytes = buffer.getvalue()

            app_logger.info(f"DPR_PROPRIETARY_TSV_SUCCESS: Infer√™ncia TSV conclu√≠da para user '{user_id}', request '{request_id}'. Tamanho do √°udio: {len(wav_bytes)} bytes.")
            return wav_bytes

        except Exception as e:
            app_logger.error(f"DPR_PROPRIETARY_TSV_ERROR: Erro durante a infer√™ncia do modelo TSV para user '{user_id}', request '{request_id}': {e!s}", exc_info=True)
            return None

# ==========¬©====DON=====¬Æ==========
# FIM DO ARQUIVO app/models/proprietary/tsv_model.py
# SELADO SOB AUTORIDADE DPR.
```
```python
# -*- coding: utf-8 -*-
#
# üúÇ REGENERA A.I.¬Æ BACKEND - EDI√á√ÉO SOBERANA IMPERIAL DEFINITIVA V10.10 üúÇ
# üúÑ ARQUIVO: app/models/proprietary/tas_model.py üúÑ
#
# Modelo de Transcri√ß√£o Anal√≠tica Soberana (TAS) Propriet√°rio DPR¬Æ.
# Desenvolvido por Paulo Ricardo de Le√£o.
#
# Este arquivo define a estrutura para o Modelo de Transcri√ß√£o de √Åudio Propriet√°rio,
# respons√°vel por converter fala em texto.
# A implementa√ß√£o dos algoritmos e a l√≥gica de infer√™ncia residem aqui.
#
# ==========¬©====DON=====¬Æ==========

import logging
import os
import numpy as np
import soundfile as sf # Necess√°rio para ler √°udio

app_logger = logging.getLogger("DPR_PROPRIETARY_TAS")

class ProprietaryTAS:
    """
    Classe para o Modelo de Transcri√ß√£o Anal√≠tica Soberana (TAS).
    Cont√©m a l√≥gica para carregar o modelo treinado e realizar infer√™ncia de transcri√ß√£o.
    """
    _model_instance = None # Pode ser a inst√¢ncia de um modelo carregado

    def __init__(self, model_path: str, inference_params: dict):
        """
        Inicializa o modelo TAS, carregando os pesos treinados do arquivo especificado.

        Args:
            model_path (str): Caminho para o arquivo do modelo TAS treinado (.dpr_tas).
            inference_params (dict): Par√¢metros de infer√™ncia (language, etc.).
        """
        self.model_path = model_path
        self.inference_params = inference_params
        self.is_loaded = False

        app_logger.info(f"DPR_PROPRIETARY_TAS: Tentando inicializar modelo TAS de: {self.model_path}")

        # --- CARREGAR O MODELO TAS ---
        if not os.path.exists(self.model_path):
             app_logger.error(f"DPR_PROPRIETARY_TAS_ERROR: Arquivo do modelo TAS n√£o encontrado: {self.model_path}")
             raise FileNotFoundError(f"Arquivo do modelo TAS propriet√°rio n√£o encontrado em: {self.model_path}")

        try:
            # TODO: Implementar a l√≥gica REAL para carregar o modelo TAS treinado.
            # Ex: carregar pesos, inicializar a arquitetura ASR.
            # self._model_instance = load_my_trained_tas_model(self.model_path)

            # Placeholder: Representa o carregamento bem-sucedido
            app_logger.info(f"DPR_PROPRIETARY_TAS: Representando carregamento do modelo TAS de: {self.model_path}")
            self._model_instance = {"name": "MeuTASv1", "status": "loaded"} # Representa a inst√¢ncia

            self.is_loaded = True
            app_logger.info("DPR_PROPRIETARY_TAS_SUCCESS: Modelo TAS carregado com sucesso.")

        except Exception as e:
            app_logger.error(f"DPR_PROPRIETARY_TAS_ERROR: Falha ao carregar modelo TAS: {e!s}", exc_info=True)
            self._model_instance = None
            self.is_loaded = False
            raise RuntimeError(f"Falha cr√≠tica ao carregar modelo TAS: {e!s}")


    # --- M√âTODO DE INFER√äNCIA PARA TRANSCRI√á√ÉO DE √ÅUDIO ---
    def transcribe(self, audio_filepath: str, user_id: str = "N/A", request_id: str = "N/A", dynamic_params: dict = None) -> str:
        """
        Transcreve √°udio de um arquivo usando o Modelo de Transcri√ß√£o Propriet√°rio.

        Args:
            audio_filepath (str): Caminho para o arquivo de √°udio a ser transcrito.
            user_id (str): ID do usu√°rio associado √† requisi√ß√£o (para logs).
            request_id (str): ID da requisi√ß√£o (para logs).
            dynamic_params (dict, optional): Par√¢metros de infer√™ncia din√¢micos por requisi√ß√£o.

        Returns:
            str: O texto transcrito ou None em caso de erro.
        """
        if not self.is_loaded or self._model_instance is None:
            app_logger.error(f"DPR_PROPRIETARY_TAS_ERROR: Tentativa de transcrever √°udio, mas modelo TAS n√£o est√° carregado para user '{user_id}', request '{request_id}'.")
            return None

        if not os.path.exists(audio_filepath):
             app_logger.error(f"DPR_PROPRIETARY_TAS_ERROR: Arquivo de √°udio n√£o encontrado para transcri√ß√£o: {audio_filepath} para user '{user_id}', device '{device_id}'.")
             return None # Arquivo precisa existir para ser transcrito

        app_logger.info(f"DPR_PROPRIETARY_TAS: Realizando infer√™ncia TAS para user '{user_id}', request '{request_id}' (arquivo: {audio_filepath})")

        # Combinar par√¢metros padr√£o com par√¢metros din√¢micos
        current_params = self.inference_params.copy()
        if dynamic_params:
            current_params.update(dynamic_params)
            app_logger.debug(f"DPR_PROPRIETARY_TAS: Usando par√¢metros din√¢micos: {dynamic_params}")


        try:
            # TODO: Implementar a l√≥gica REAL de infer√™ncia usando o modelo TAS.
            # Precisa ler o arquivo de √°udio (ex: usando soundfile.read),
            # pr√©-processar os dados de √°udio conforme exigido pelo modelo,
            # e passar para o modelo para transcri√ß√£o.
            # Usa current_params (ex: language).
            # Ex: audio_data_np, sr = sf.read(audio_filepath)
            #     processed_audio = preprocess_audio_for_my_tas(audio_data_np, sr, **current_params)
            #     transcribed_text = self._model_instance.transcribe(processed_audio)

            # Placeholder: Representa a transcri√ß√£o (retorna um texto fixo ou baseado no nome do arquivo)
            simulated_transcription = f"Transcri√ß√£o pela Regenera A.I. (TAS) do √°udio em {os.path.basename(audio_filepath)}. Par√¢metros usados: {current_params}"
            
            app_logger.info(f"DPR_PROPRIETARY_TAS_SUCCESS: Infer√™ncia TAS conclu√≠da para user '{user_id}', request '{request_id}'. Texto: {simulated_transcription[:100]}...")
            return simulated_transcription # Retorna o texto transcrito (representa√ß√£o)

        except Exception as e:
            app_logger.error(f"DPR_PROPRIETARY_TAS_ERROR: Erro durante a infer√™ncia do modelo TAS para user '{user_id}', request '{request_id}': {e!s}", exc_info=True)
            return None

# ==========¬©====DON=====¬Æ==========
# FIM DO ARQUIVO app/models/proprietary/tas_model.py
# SELADO SOB AUTORIDADE DPR.
```
```python
# -*- coding: utf-8 -*-
#
# üúÇ REGENERA A.I.¬Æ BACKEND - EDI√á√ÉO SOBERANA IMPERIAL DEFINITIVA V10.10 üúÇ
# üúÑ ARQUIVO: app/core/quantum_core.py üúÑ
#
# Core de Processamento Qu√¢ntico.
# Desenvolvido por Paulo Ricardo de Le√£o.
#
# Este m√≥dulo √© respons√°vel por gerenciar a conex√£o e a execu√ß√£o de Circuitos
# Qu√¢nticos Propriet√°rios na IBM Quantum Platform (hardware ou simulador AER).
# Ele atua como middleware entre algoritmos qu√¢nticos definidos e o hardware/simulador,
# mantendo a soberania da l√≥gica algor√≠tmica e dos dados.
#
# ==========¬©====DON=====¬Æ==========

import logging
import os

# --- IMPORTA√á√ïES PARA INTERA√á√ÉO COM IBM QUANTUM VIA QISKIT ---
try:
    from qiskit_ibm_provider import IBMProvider, least_busy # least_busy pode ser √∫til
    from qiskit_aer import AerSimulator # Para simula√ß√£o local
    from qiskit import QuantumCircuit, transpile, assemble, Aer # Elementos b√°sicos de Qiskit
    from qiskit.result import Result # Para tipagem do resultado
    # TODO: Importar classes para mitiga√ß√£o de ru√≠do, compila√ß√£o qu√¢ntica adaptada
    # from qiskit.transpiler import PassManager
    # from qiskit_aer.noise import NoiseModel
    # from qiskit.utils.mitigation import zne
    IBM_QUANTUM_AVAILABLE = True
except ImportError:
    IBM_QUANTUM_AVAILABLE = False
    # app_logger.warning("DPR_QUANTUM_CORE: Bibliotecas Qiskit n√£o instaladas. Funcionalidade qu√¢ntica indispon√≠vel.")


from app.utils.logging_config import log_audit # Importa o logger de auditoria
# from app.core.config import load_config # Importar config para par√¢metros qu√¢nticos (evitar import circular se poss√≠vel)


app_logger = logging.getLogger("DPR_QUANTUM_CORE")

class QuantumCore:
    """
    Gerenciador Central para Execu√ß√£o de Circuitos Qu√¢nticos Propriet√°rios.
    Orquestra a intera√ß√£o com backends IBM Quantum ou simuladores locais.
    """
    _provider: IBMProvider = None
    _backend = None # Backend (hardware ou simulador)
    _simulator: AerSimulator = None
    _is_initialized: bool = False
    _initialization_error: str = None
    _config_ref: dict = None # Refer√™ncia √† configura√ß√£o

    @classmethod
    def initialize(cls, config: dict):
        """
        Inicializa o Core Qu√¢ntico, configurando o provedor e o backend alvo.
        Chamado durante a inicializa√ß√£o da aplica√ß√£o.
        """
        if cls._is_initialized:
            app_logger.debug("DPR_QUANTUM_CORE: QuantumCore j√° inicializado.")
            return

        cls._config_ref = config
        cls._initialization_error = None # Reset error

        if not IBM_QUANTUM_AVAILABLE:
            cls._initialization_error = "Bibliotecas Qiskit n√£o instaladas. Funcionalidade qu√¢ntica indispon√≠vel."
            app_logger.critical(f"DPR_QUANTUM_CORE_FATAL: {cls._initialization_error}")
            log_audit(logging.CRITICAL, "Inicializa√ß√£o do Core Qu√¢ntico falhou.", event_type="QUANTUM_INIT_FAILED", reason="QISKIT_NOT_INSTALLED")
            cls._is_initialized = False
            return

        ibm_token = config.get("DPR_IBM_QUANTUM_TOKEN")
        ibm_instance = config.get("DPR_IBM_QUANTUM_INSTANCE")
        ibm_backend_name = config.get("DPR_IBM_QUANTUM_BACKEND")
        ibm_simulator_name = config.get("DPR_IBM_QUANTUM_SIMULATOR", "aer_simulator") # Default simulador AER
        quantum_mode = config.get("DPR_QUANTUM_EXECUTION_MODE", "simulator")

        # 1. Inicializar Simulador AER (sempre tentamos)
        app_logger.info(f"DPR_QUANTUM_CORE: Inicializando simulador AER: {ibm_simulator_name}")
        try:
             cls._simulator = AerSimulator() # Pode ser Aer.get_backend(ibm_simulator_name)
             app_logger.info("DPR_QUANTUM_CORE_SUCCESS: Simulador AER inicializado.")
        except Exception as e:
             app_logger.error(f"DPR_QUANTUM_CORE_ERROR: Falha ao inicializar simulador AER: {e!s}", exc_info=True)
             log_audit(logging.ERROR, "Inicializa√ß√£o do simulador AER falhou.", event_type="QUANTUM_INIT_FAILED", backend="aer_simulator", error=str(e))
             cls._simulator = None # Garante que √© None em caso de falha

        # 2. Inicializar Provedor e Backend IBM Quantum (se modo hardware)
        if quantum_mode == "hardware":
            app_logger.info(f"DPR_QUANTUM_CORE: Inicializando IBM Quantum Provider para modo 'hardware'...")
            # Verificar se as configura√ß√µes cr√≠ticas para hardware est√£o presentes e seguras
            if not ibm_token or not ibm_instance or not ibm_backend_name:
                cls._initialization_error = "Configura√ß√µes IBM Quantum (token, instance, backend) incompletas/inseguras para modo 'hardware'."
                app_logger.fatal(f"DPR_QUANTUM_CORE_FATAL: {cls._initialization_error}")
                log_audit(logging.CRITICAL, "Inicializa√ß√£o do Core Qu√¢ntico falhou: Configura√ß√µes incompletas/inseguras para hardware.", event_type="QUANTUM_INIT_FAILED", reason="HARDWARE_CONFIG_INCOMPLETE")
                # Permite a inicializa√ß√£o se o simulador estiver dispon√≠vel, mas o hardware falha
                if cls._simulator is not None:
                    cls._is_initialized = True # Core inicializado com simulador como fallback
                    app_logger.warning("DPR_QUANTUM_CORE_WARN: Hardware IBM Quantum indispon√≠vel devido a configura√ß√£o. Usando simulador como fallback.")
                else:
                     cls._is_initialized = False # Core completamente inoperante
                     log_audit(logging.CRITICAL, "Inicializa√ß√£o do Core Qu√¢ntico falhou: Hardware (config) E simulador indispon√≠veis.", event_type="QUANTUM_INIT_FAILED", reason="NO_QUANTUM_BACKEND_AVAILABLE")
                return # Finaliza a inicializa√ß√£o (sucesso parcial ou falha)


            try:
                 # Autenticar com o provedor IBM Quantum
                 # IBMProvider.save_account(token=ibm_token, instance=ibm_instance, overwrite=True) # Pode ser feito externamente
                 cls._provider = IBMProvider(token=ibm_token, instance=ibm_instance) # Usar token/instance diretamente

                 # Opcional: Usar least_busy para encontrar um backend dispon√≠vel
                 # from qiskit.providers.provider_exceptions import NoQubits
                 # try:
                 #     large_enough_qubits = 15 # Exemplo, ajustar conforme necessidade do circuito
                 #     cls._backend = least_busy(cls._provider.backends(
                 #          filters=lambda b: b.configuration().n_qubits >= large_enough_qubits
                 #          and not b.configuration().simulator # Certifica que n√£o √© simulador
                 #          and b.status().operational == True),
                 #          retired=False
                 #     )
                 #     ibm_backend_name = cls._backend.name # Atualiza nome se usou least_busy
                 #     app_logger.info(f"DPR_QUANTUM_CORE: Least busy IBM Quantum backend found: '{ibm_backend_name}'.")
                 # except NoQubits:
                 #      app_logger.warning(f"DPR_QUANTUM_CORE_WARN: Nenhum backend IBM Quantum operacional com {large_enough_qubits}+ qubits encontrado.")
                 #      cls._backend = None # Define como None se n√£o encontrar

                 # Carregar o backend espec√≠fico configurado
                 if cls._backend is None: # Se least_busy n√£o encontrou ou n√£o foi usado
                     cls._backend = cls._provider.get_backend(ibm_backend_name)
                     app_logger.info(f"DPR_QUANTUM_CORE_SUCCESS: Backend IBM Quantum '{ibm_backend_name}' carregado.")

                 # Verificar se o backend est√° operacional
                 if cls._backend is not None and not cls._backend.status().operational:
                      app_logger.warning(f"DPR_QUANTUM_CORE_WARN: Backend IBM Quantum '{ibm_backend_name}' n√£o est√° operacional no momento.")
                      cls._backend = None # Tratar como indispon√≠vel

                 if cls._backend is None:
                     cls._initialization_error = f"Backend IBM Quantum '{ibm_backend_name}' n√£o dispon√≠vel ou n√£o operacional."
                     app_logger.fatal(f"DPR_QUANTUM_CORE_FATAL: {cls._initialization_error}")
                     log_audit(logging.CRITICAL, "Inicializa√ß√£o do Core Qu√¢ntico falhou: Backend de hardware indispon√≠vel/n√£o operacional.", event_type="QUANTUM_INIT_FAILED", backend=ibm_backend_name)
                     # Permite a inicializa√ß√£o se o simulador estiver dispon√≠vel, mas o hardware falha
                     if cls._simulator is not None:
                         cls._is_initialized = True # Core inicializado com simulador como fallback
                         app_logger.warning("DPR_QUANTUM_CORE_WARN: Hardware IBM Quantum indispon√≠vel. Usando simulador como fallback.")
                     else:
                          cls._is_initialized = False # Core completamente inoperante
                          log_audit(logging.CRITICAL, "Inicializa√ß√£o do Core Qu√¢ntico falhou: Hardware E simulador indispon√≠veis.", event_type="QUANTUM_INIT_FAILED", reason="NO_QUANTUM_BACKEND_AVAILABLE")
                     return # Finaliza a inicializa√ß√£o (sucesso parcial ou falha)


                 app_logger.info(f"DPR_QUANTUM_CORE_SUCCESS: IBM Quantum Provider e Backend '{ibm_backend_name}' inicializados com sucesso.")
                 log_audit(logging.INFO, "IBM Quantum Provider e Backend inicializados.", event_type="QUANTUM_INIT_SUCCESS", backend=ibm_backend_name)

            except Exception as e:
                cls._initialization_error = f"Falha na inicializa√ß√£o do IBM Quantum Provider ou Backend: {e!s}"
                app_logger.fatal(f"DPR_QUANTUM_CORE_FATAL: {cls._initialization_error}", exc_info=True)
                log_audit(logging.CRITICAL, "Inicializa√ß√£o do Core Qu√¢ntico falhou: Erro no Provider/Backend IBM.", event_type="QUANTUM_INIT_FAILED", reason="IBM_PROVIDER_ERROR", error=str(e))
                cls._provider = None
                cls._backend = None
                # Permite a inicializa√ß√£o se o simulador estiver dispon√≠vel como fallback
                if cls._simulator is not None:
                     cls._is_initialized = True # Core inicializado com simulador como fallback
                     app_logger.warning("DPR_QUANTUM_CORE_WARN: Hardware IBM Quantum indispon√≠vel devido a erro. Usando simulador como fallback.")
                else:
                     cls._is_initialized = False # Core completamente inoperante
                     log_audit(logging.CRITICAL, "Inicializa√ß√£o do Core Qu√¢ntico falhou: Erro no Provider/Backend IBM E simulador indispon√≠vel.", event_type="QUANTUM_INIT_FAILED", reason="NO_QUANTUM_BACKEND_AVAILABLE_AFTER_ERROR")
                return # Finaliza a inicializa√ß√£o (sucesso parcial ou falha)

        # 3. Finalizar inicializa√ß√£o
        if cls._simulator is not None or cls._backend is not None:
            cls._is_initialized = True
            app_logger.info("DPR_QUANTUM_CORE_SUCCESS: QuantumCore inicializado. Pelo menos um backend (simulador ou hardware) est√° dispon√≠vel.")
        else:
            cls._is_initialized = False
            cls._initialization_error = "Nenhum backend qu√¢ntico (simulador ou hardware) p√¥de ser inicializado."
            app_logger.fatal(f"DPR_QUANTUM_CORE_FATAL: {cls._initialization_error}")
            log_audit(logging.CRITICAL, "Inicializa√ß√£o do Core Qu√¢ntico falhou: Nenhum backend dispon√≠vel.", event_type="QUANTUM_INIT_FAILED", reason="NO_BACKEND_AVAILABLE")


    # --- VERIFICA STATUS DE DISPONIBILIDADE ---
    @classmethod
    def is_available(cls) -> bool:
        """Retorna True se o QuantumCore foi inicializado e tem pelo menos um backend dispon√≠vel."""
        return cls._is_initialized and (cls._simulator is not None or cls._backend is not None)

    @classmethod
    def get_initialization_error(cls) -> str | None:
        """Retorna a mensagem de erro se a inicializa√ß√£o falhou."""
        return cls._initialization_error

    # --- OBT√âM BACKEND ATUAL ---
    @classmethod
    def _get_current_backend(cls):
         """
         Retorna o backend qu√¢ntico a ser usado, priorizando hardware se configurado
         e dispon√≠vel, caso contr√°rio, usando o simulador.
         """
         if not cls._is_initialized:
              app_logger.error("DPR_QUANTUM_CORE_ERROR: Tentativa de obter backend, mas QuantumCore n√£o inicializado.")
              return None

         quantum_mode = cls._config_ref.get("DPR_QUANTUM_EXECUTION_MODE", "simulator")

         if quantum_mode == "hardware" and cls._backend is not None:
              if not cls._backend.status().operational: # Verifica status operacional antes de usar
                  app_logger.warning(f"DPR_QUANTUM_CORE_WARN: Backend de hardware '{cls._backend.name}' n√£o est√° operacional. Falhando ou tentando fallback.")
                  if cls._simulator is not None:
                      app_logger.warning("DPR_QUANTUM_CORE_WARN: Usando simulador AER como fallback para hardware inoperante.")
                      return cls._simulator
                  else:
                      app_logger.error("DPR_QUANTUM_CORE_ERROR: Backend de hardware inoperante e simulador n√£o dispon√≠vel.")
                      return None
              return cls._backend # Usa hardware se operacional
         elif cls._simulator is not None:
              return cls._simulator # Usa simulador
         else:
              app_logger.error("DPR_QUANTUM_CORE_ERROR: Nenhum backend qu√¢ntico dispon√≠vel.")
              return None


    # --- EXECUTA CIRCUITO QU√ÇNTICO ---
    @classmethod
    def execute_quantum_circuit(cls, quantum_circuit: QuantumCircuit, shots: int | None = None, user_id="N/A", device_id="N/A", request_id="N/A") -> dict | None:
        """
        Executa um QuantumCircuit no backend qu√¢ntico configurado.
        Aplica transpile, mitiga√ß√£o de ru√≠do (se hardware) e obt√©m contagens.

        Args:
            quantum_circuit (QuantumCircuit): O circuito qu√¢ntico a ser executado.
            shots (int, optional): N√∫mero de execu√ß√µes do circuito. Defaults to configured value.
            user_id (str): ID do usu√°rio (para logs).
            device_id (str): ID do dispositivo (para logs).
            request_id (str): ID da requisi√ß√£o (para logs).

        Returns:
            dict: O dicion√°rio de contagens do resultado das medi√ß√µes, ou None em caso de falha.
        """
        if not cls.is_available():
            app_logger.error(f"DPR_QUANTUM_CORE_ERROR: Core Qu√¢ntico n√£o dispon√≠vel para execu√ß√£o de circuito para user '{user_id}', request '{request_id}'.")
            log_audit(logging.ERROR, "Execu√ß√£o de circuito qu√¢ntico falhou: Core Qu√¢ntico indispon√≠vel.", event_type="QUANTUM_EXECUTION_FAILED", reason="QUANTUM_CORE_UNAVAILABLE", user_id=user_id, device_id=device_id, request_id=request_id)
            return None

        backend = cls._get_current_backend()
        if backend is None:
            app_logger.error(f"DPR_QUANTUM_CORE_ERROR: Nenhum backend qu√¢ntico dispon√≠vel ou operacional para execu√ß√£o de circuito para user '{user_id}', request '{request_id}'.")
            log_audit(logging.ERROR, "Execu√ß√£o de circuito qu√¢ntico falhou: Nenhum backend dispon√≠vel.", event_type="QUANTUM_EXECUTION_FAILED", reason="NO_BACKEND_AVAILABLE_FOR_EXECUTION", user_id=user_id, device_id=device_id, request_id=request_id)
            return None

        # Obter shots da config se n√£o especificado
        if shots is None:
             shots = cls._config_ref.get("DPR_INFERENCE_PARAMS", {}).get("quantum", {}).get("shots", 8192)


        backend_name = backend.name
        app_logger.info(f"DPR_QUANTUM_CORE: Iniciando execu√ß√£o de circuito em '{backend_name}' (shots={shots}) para user '{user_id}', request '{request_id}'.")
        log_audit(logging.INFO, "Execu√ß√£o de circuito qu√¢ntico iniciada.", event_type="QUANTUM_EXECUTION_START", user_id=user_id, device_id=device_id, request_id=request_id, backend=backend_name, shots=shots)

        try:
            # TODO: Implementar transpile avan√ßado com otimiza√ß√µes customizadas e mitiga√ß√£o de ru√≠do
            # A transplica√ß√£o √© essencial para adaptar o circuito ao hardware.
            # Mitigation de ru√≠do √© CR√çTICA para resultados em hardware NISQ.
            
            # --- COMPILAR CIRCUITO PARA O BACKEND ALVO ---
            # Exemplo b√°sico de transpila√ß√£o
            compiled_circuit = transpile(quantum_circuit, backend=backend, optimization_level=1) # Ajustar opt_level

            # TODO: Aplicar t√©cnicas de MITIGA√á√ÉO DE RU√çDO se o backend for hardware REAL.
            # Isso envolve envolver o circuito compilado em protocolos de mitiga√ß√£o (ZNE, PEC, etc.)
            # compiled_circuit_for_mitigation = apply_noise_mitigation_protocol(compiled_circuit, backend)

            # --- EXECUTAR O CIRCUITO ---
            # Em um sistema real de produ√ß√£o, jobs de hardware s√£o ASS√çNCRONOS.
            # job = backend.run(compiled_circuit_for_mitigation, shots=shots) # Executa o job
            # job_id = job.job_id()
            # app_logger.info(f"... Job submission complete. Job ID: {job_id}")
            # return {"status": "submitted", "job_id": job_id} # Retornaria um status e ID do job

            # PARA ESTE EXEMPLO, USAMOS EXECU√á√ÉO S√çNCRONA PARA SIMPLICIDADE (funciona bem para simulador)
            app_logger.debug("DPR_QUANTUM_CORE: (S√≠ncrono) Aguardando resultados do job...")
            job = backend.run(compiled_circuit, shots=shots) # Execu√ß√£o s√≠ncrona/poll
            result: Result = job.result()

            # --- OBTER RESULTADOS (CONTAMENTOS) ---
            # get_counts pode aplicar mitiga√ß√£o de erros de medi√ß√£o se configurado no job/backend.
            counts = result.get_counts(quantum_circuit) # Get counts for the ORIGINAL circuit (mitigation applied implicitly/explicitly)

            # TODO: Aplicar P√ìS-PROCESSAMENTO/DECODIFICA√á√ÉO/MITIGA√á√ÉO FINAL nos resultados se necess√°rio
            # counts_mitigated = apply_post_processing_and_mitigation(counts, result, backend)

            app_logger.info(f"DPR_QUANTUM_CORE_SUCCESS: Execu√ß√£o de circuito conclu√≠da e resultados obtidos para user '{user_id}', request '{request_id}'.")
            log_audit(logging.INFO, "Execu√ß√£o de circuito qu√¢ntico conclu√≠da com sucesso.", event_type="QUANTUM_EXECUTION_COMPLETE", user_id=user_id, device_id=device_id, request_id=request_id, backend=backend_name, shots=shots, counts_preview=str(counts)[:200]) # Log preview das contagens

            return counts # Retorna o dicion√°rio de contagens mitigadas/processadas

        except Exception as e:
            app_logger.error(f"DPR_QUANTUM_CORE_ERROR: Erro durante a execu√ß√£o do circuito qu√¢ntico em '{backend_name}' para user '{user_id}', request '{request_id}': {e!s}", exc_info=True)
            log_audit(logging.ERROR, "Erro durante a execu√ß√£o qu√¢ntica.", event_type="QUANTUM_EXECUTION_FAILED", user_id=user_id, device_id=device_id, request_id=request_id, error=str(e), backend=backend_name)
            return None # Indica falha


    # TODO: Adicionar m√©todos para gerenciar jobs ass√≠ncronos, se implementado acima.
    # @classmethod
    # def get_job_result(cls, job_id: str):
    #      """Obt√©m o resultado de um job qu√¢ntico submetido assincronamente."""
    #      ... (l√≥gica para recuperar job do provider e retornar resultado/status)


# TODO: M√≥dulo ou classes separadas para definir a L√ìGICA dos Circuitos Qu√¢nticos Espec√≠ficos
# Ex: wellbeing_qnn.py, qaoa_optimizer.py
# Estes m√≥dulos construiriam o objeto QuantumCircuit usando dados de entrada,
# e ent√£o CHAMARIAM QuantumCore.execute_quantum_circuit para rod√°-lo.

# Exemplo CONCEITUAL de como a L√≥gica Qu√¢ntica Propriet√°ria construiria e usaria um circuito:
# def build_my_proprietary_wellbeing_qnn(features: dict, qnn_params: dict) -> QuantumCircuit:
#      """Constr√≥i o circuito QNN propriet√°rio para predi√ß√£o de bem-estar."""
#      # TODO: Mapear features para par√¢metros de codifica√ß√£o qu√¢ntica.
#      # TODO: Construir circuito de Codifica√ß√£o Qu√¢ntica (S(x)).
#      # TODO: Construir circuito Variacional (V(theta)) com camadas de rota√ß√£o e emaranhamento.
#      # TODO: Combinar S(x) e V(theta).
#      # TODO: Adicionar medi√ß√µes ao final.
#      n_qubits = len(features) # Exemplo simplista
#      qc = QuantumCircuit(n_qubits, n_qubits)
#      # Add encoding based on features...
#      # Add variational layers based on qnn_params...
#      qc.measure(list(range(n_qubits)), list(range(n_qubits))) # Medir todos
#      return qc

# def decode_qnn_results(counts: dict) -> float:
#      """Decodifica o resultado (contagens) do QNN para obter a predi√ß√£o de bem-estar."""
#      # TODO: Implementar l√≥gica para converter contagens em probabilidade/score cl√°ssico.
#      # Isso pode envolver c√°lculo de expectativa de observ√°vel a partir das contagens.
#      # Ex: probabilidade_estado_00 = counts.get('00', 0) / sum(counts.values()) # Exemplo trivial 2-qubits
#      # Mapear para risco de crise...
#      return 0.5 # Probabilidade de risco simulada

# Nota: A l√≥gica REAL dos algoritmos QML/QAOA/VQE e o treinamento H√≠brido CL√ÅSSICO-QU√ÇNTICO
# reside NESTA Camada Propriet√°ria (outros arquivos dentro de models.proprietary ou core).
# QuantumCore APENAS executa circuitos e lida com o backend.

# ==========¬©====DON=====¬Æ==========
# FIM DO ARQUIVO app/core/quantum_core.py
# SELADO SOB AUTORIDADE DPR.
```
```python
# -*- coding: utf-8 -*-
#
# üúÇ REGENERA A.I.¬Æ BACKEND - EDI√á√ÉO SOBERANA IMPERIAL DEFINITIVA V10.10 üúÇ
# üúÑ ARQUIVO: app/models/proprietary/__init__.py üúÑ
#
# N√∫cleo de Modelagem Propriet√°ria DPR¬Æ - Inicializador de M√≥dulos.
# Desenvolvido por Paulo Ricardo de Le√£o.
#
# Este arquivo inicializa o namespace para os Modelos de IA Propriet√°rios
# (TLM, TSV, TAS, e Conceitos Qu√¢nticos Pr√≥prios).
#
# A implementa√ß√£o REAL dos algoritmos, arquiteturas e l√≥gica de infer√™ncia reside
# nos arquivos Python espec√≠ficos dentro deste diret√≥rio (`proprietary/`).
# O Core Qu√¢ntico est√° em `app/core/quantum_core.py`.
# O carregamento destas classes e inst√¢ncias √© orquestrado por `app/core/models.py`.
#
# ==========¬©====DON=====¬Æ==========

# Este arquivo '__init__.py' serve primariamente para marcar o diret√≥rio 'proprietary'
# como um pacote Python e permitir que os m√≥dulos dentro dele sejam importados
# por `app.core.models`.
# Nenhuma l√≥gica de inicializa√ß√£o complexa deve residir aqui.

# Metadata sobre o pacote propriet√°rio
__version__ = "1.0.DPR_AUTORAL"
__author__ = "Paulo Ricardo de Le√£o"
__copyright__ = "Copyright ¬© 2024-2025 Paulo Ricardo de Le√£o"
__status__ = "Soberano e Autorizado por DPR"

# Ao carregar classes dinamicamente em `app.core.models`, garantimos
# que os arquivos de modelo (`tlm_model.py`, etc.) s√£o importados no runtime,
# onde as classes `ProprietaryTLM`, `ProprietaryTSV`, `ProprietaryTAS`, etc.,
# estar√£o definidas.


# ==========¬©====DON=====¬Æ==========
# FIM DO ARQUIVO app/models/proprietary/__init__.py
# SELADO SOB AUTORIDADE DPR.
```
```python
# -*- coding: utf-8 -*-
#
# üúÇ REGENERA A.I.¬Æ BACKEND - EDI√á√ÉO SOBERANA IMPERIAL DEFINITIVA V10.10 üúÇ
# üúÑ ARQUIVO: app/models/proprietary/tlm_model.py üúÑ
#
# Modelo de Linguagem Transcendente (TLM) Propriet√°rio DPR¬Æ.
# Desenvolvido por Paulo Ricardo de Le√£o.
#
# Este arquivo define a estrutura para o Modelo de Linguagem Propriet√°rio,
# respons√°vel pela gera√ß√£o de texto. A implementa√ß√£o dos algoritmos de aprendizado,
# a arquitetura neural, os pesos treinados e a l√≥gica de infer√™ncia residem aqui.
#
# ==========¬©====DON=====¬Æ==========
